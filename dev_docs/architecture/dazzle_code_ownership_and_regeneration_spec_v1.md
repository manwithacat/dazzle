# DAZZLE Code Ownership and Regeneration Specification (v1)

## 1. Purpose and Scope

1. Define a clear, deterministic strategy for **code ownership**, **regeneration**, and **feedback** between:
   - DAZZLE DSL / AppSpec (structural truth),
   - Generated code (projection of that truth),
   - User-authored code (custom logic and UI).
2. Ensure that users can:
   - Regenerate apps when the spec changes **without losing manual changes**.
   - Safely customise behaviour and presentation.
   - Provide feedback on generated UIs that can be incorporated into future generations.
3. Avoid relying on hidden, automatic LLM reconciliation. Treat any LLM-assisted reconciliation as an **explicit tool**, not background magic.

---

## 2. Core Principles

1. **Single Source of Structural Truth**
   - All structural aspects (data model, routes, workspaces, semantic layout) must originate from the DSL / AppSpec.
   - Do not treat edited generated code as an authoritative structural source.

2. **Strict Separation of Concerns**
   - Generated code and user code must be physically separated at the directory and file level.
   - Regeneration must only rewrite generated code, never user code.

3. **Deterministic Regeneration**
   - Given the same DSL / AppSpec and generator version, DAZZLE must produce the same generated code structure.
   - Regeneration must be a predictable, repeatable operation.

4. **Explicit Feedback Loop**
   - When users want changes reflected in the spec or in future generations, they must:
     - Edit the DSL / AppSpec, or
     - Use defined feedback / preference mechanisms.
   - LLM-based reconciliation is opt-in and visible to the user.

---

## 3. Directory Layout and Ownership

### 3.1 High-Level Structure

Implement the following canonical layout for a DAZZLE-generated app (example in Next.js/TypeScript, but keep the concept language-agnostic):

```text
app/
  generated/          # Fully owned by DAZZLE generator
    workspaces/
      invoices_main.page.tsx
      ...
    api/
      invoices/
        route.ts
    components/
      ...
  custom/             # Fully owned by the user
    workspaces/
      invoices_main.override.tsx
    components/
      BrandHeader.tsx
      CustomKpiCard.tsx
      ...
    component_registry.ts
  shared/             # Stable contracts and types; mostly generated, rarely hand-edited
    models.ts
    workspace_contracts.ts
    layout_plans/
      invoices_main.layout.json
    ...
dazzle_manifest.json # Generation metadata
```

### 3.2 Ownership Rules

1. **`app/generated/`**
   - Entirely owned by DAZZLE.
   - The generator may delete and recreate this directory on each regeneration.
   - Users must not rely on manual edits here. Edits are allowed in practice but considered “unsafe” and detected by tooling.

2. **`app/custom/`**
   - Entirely owned by the user.
   - The generator MUST NEVER overwrite or delete files in this directory.
   - All user-defined behaviour, overrides, and styling customisations should be located here.

3. **`app/shared/`**
   - Contains stable interfaces, types, and layout plans.
   - Primarily generated by DAZZLE, but:
     - The generator should avoid destructive operations.
     - If manual edits are allowed, they must be clearly documented and minimal.
   - Prefer a pattern where `shared/` is re-generated from spec with backwards-compatible changes.

4. **`dazzle_manifest.json`**
   - Owned by DAZZLE; must be updated on each generation.
   - Used to track generator version, spec hash, and content hashes of generated files.

---

## 4. Manifest and Change Tracking

### 4.1 Manifest Structure

Implement `dazzle_manifest.json` with at least:

```json
{
  "generator_version": "x.y.z",
  "spec_hash": "sha256:...",
  "generated_files": {
    "app/generated/workspaces/invoices_main.page.tsx": {
      "content_hash": "sha256:...",
      "generated_at": "2025-11-27T12:34:56Z"
    },
    "app/shared/layout_plans/invoices_main.layout.json": {
      "content_hash": "sha256:...",
      "generated_at": "2025-11-27T12:34:56Z"
    }
  }
}
```

### 4.2 Use of Manifest

1. On each regeneration:
   - Compute a hash of the DSL / AppSpec.
   - Compare with `spec_hash` in the manifest.
   - If different, proceed with regeneration; update `spec_hash`.

2. For each file in `app/generated/` and `shared/`:
   - Compare the current file content hash with the manifest.
   - If they differ before regeneration, mark the file as **locally modified**.

3. Store any local modifications in an in-memory report for diagnostic commands (see §7).

---

## 5. Generated vs User Code Interaction

### 5.1 Generated Workspace Pages

1. For each workspace, generate a thin page file in `app/generated/workspaces` that:

   - Imports layout plans and shared contracts from `shared/`.
   - Uses a shared renderer and a user-owned component registry.

2. Example pattern (TypeScript/React):

```ts
// app/generated/workspaces/invoices_main.page.tsx
import { workspaceLayout } from "@/shared/layout_plans/invoices_main";
import { renderWorkspace } from "@/shared/workspace_renderer";
import { componentRegistry } from "@/custom/component_registry";

export default function InvoicesMainPage() {
  return renderWorkspace({
    layout: workspaceLayout,
    components: componentRegistry,
  });
}
```

3. The generator must not embed business logic in these pages beyond wiring layout → renderer → registry.

### 5.2 User Component Registry

1. Require a `app/custom/component_registry.ts` file that maps semantic component roles to concrete components:

```ts
import { DefaultKpiCard } from "@/shared/components/DefaultKpiCard";
import { DefaultTable } from "@/shared/components/DefaultTable";
import { BrandHeader } from "@/custom/components/BrandHeader";
import { CustomKpiCard } from "@/custom/components/CustomKpiCard";

export const componentRegistry = {
  kpiCard: CustomKpiCard ?? DefaultKpiCard,
  table: DefaultTable,
  header: BrandHeader,
  // etc.
};
```

2. The registry is:

   - Fully user-owned.
   - Not modified by the generator.
   - The primary hook for global UI customisation.

3. During regeneration, the generator must preserve the registry contract:
   - Do not rename keys arbitrarily.
   - If new component roles are added, append them in a non-breaking way and document them.

### 5.3 Workspace Overrides

1. Allow users to replace a generated workspace page with an override:

   - If `app/custom/workspaces/{workspace_id}.override.tsx` exists, the app router should prefer it over the generated one.
   - The override should ideally consume `shared` contracts (e.g. layout plan, data hooks) but may also be fully custom.

2. The generator:

   - Must not create or delete `*.override.*` files.
   - Must not attempt to modify overrides.
   - May generate stubs or documentation to guide users, but only on explicit command.

---

## 6. Feedback and Preferences Layer

### 6.1 UI Preferences Concept

1. Introduce a **preferences layer** for each workspace that captures user feedback about the layout and behaviour, independent of code edits.
2. Store preferences in a structured file, e.g.:

```json
// app/custom/ui_preferences/invoices_main.json
{
  "hidden_signals": ["some_low_priority_metric"],
  "emphasised_signals": ["overdue_summary"],
  "density": "compact",
  "notes": "Move filters to sidebar, hide low-value metrics."
}
```

3. Treat preferences as:

   - User-owned configuration.
   - An overlay on top of the baseline layout logic.

### 6.2 Preferences Application

1. During layout plan generation, merge three layers:

   1. Core semantic model (from DSL / AppSpec).
   2. Persona and engine rules (from the layout engine).
   3. User preferences (from `ui_preferences`).

2. Adjust:

   - Attention weights (e.g. boost emphasised signals, downweight hidden ones).
   - Visibility (exclude hidden signals from primary surfaces; mark them for tabs/drawers).
   - Density (e.g. “compact” → choose denser archetype variant or spacing).

3. Ensure this merge is deterministic and documented.

### 6.3 In-App Feedback

1. Provide a “Review Mode” in generated apps (longer-term):

   - Allow users to rate a workspace (e.g. 1–5 for clarity, clutter).
   - Provide toggles like:
     - “This page feels too busy”
     - “This important thing is hard to find”
     - “I never use [X]”

2. Persist this feedback into the corresponding `ui_preferences` file as structured data.

3. On next regeneration, incorporate preferences into layout planning.

---

## 7. CLI Commands and Workflow

### 7.1 `dazzle generate`

1. Implement `dazzle generate` as the primary generation command:

   - Reads DSL / AppSpec.
   - Generates:
     - `app/generated/*`
     - `app/shared/*`
     - `dazzle_manifest.json`
   - Respects ownership rules:
     - Never writes to `app/custom/*`.

2. Allow options such as:

   - `--force` to regenerate even if `spec_hash` unchanged.
   - `--dry-run` to show planned changes without writing.

### 7.2 `dazzle regenerate`

1. Provide a convenience alias `dazzle regenerate` that:

   - Deletes `app/generated/*` safely.
   - Re-runs `dazzle generate`.
   - Leaves `app/custom/*` untouched.

2. Before deletion, optionally:

   - Compare existing `generated` files with manifest hashes.
   - If differences are detected, show a warning about local edits (see §7.4).

### 7.3 `dazzle doctor`

1. Implement `dazzle doctor` to inspect project health:

   - Compare `app/generated/*` and `app/shared/*` against `dazzle_manifest.json`.
   - Report:
     - Locally modified generated files.
     - Mismatched spec hash vs manifest.
     - Missing key files (e.g. component registry, layout plans).

2. Output must:

   - Clearly warn if generated files were hand-edited.
   - Offer guidance:
     - Suggest moving logic to `app/custom`.
     - Suggest using LLM-assisted `capture-changes` if available.

### 7.4 `dazzle capture-changes` (LLM-assisted, optional/advanced)

1. Implement an optional `dazzle capture-changes` command for advanced users:

   - Scan for differences between:
     - The last generated version (as per manifest hashes or stored snapshots).
     - The current `app/generated` files.
   - For each changed file:
     - Extract diff hunks.
     - Use an LLM prompt to infer potential DSL/AppSpec changes required to represent these differences structurally.

2. Present proposed spec patches to the user:

   - Do not auto-apply.
   - Allow the user to:
     - Accept, reject, or edit the suggested changes.
   - Once accepted, update the DSL/AppSpec and re-run `dazzle generate`.

3. Clearly document that:

   - This is an **explicit** reconciliation step.
   - Users are responsible for confirming and applying structural changes.

---

## 8. Mixed Files and Generated Regions (Escape Hatch)

### 8.1 Generated Region Markers

1. In cases where mixed files are unavoidable (e.g. framework constraints), use explicit region markers:

```ts
// <dazzle:begin generated id="invoices_table_section">
...
// </dazzle:end generated id="invoices_table_section">
```

2. For each marked region:

   - Treat it as generator-owned.
   - On regeneration:
     - Recompute the content for each `generated id`.
     - Replace only that region, leaving the rest of the file intact.

3. Document that any user edits inside a generated region may be lost.

### 8.2 Regeneration Logic for Mixed Files

1. For a mixed file:

   - Parse the file for all `<dazzle:begin ...>` / `<dazzle:end ...>` pairs.
   - For each region:
     - Generate new content based on the current spec.
     - Replace existing region content.
   - Preserve all content outside generated regions.

2. Track region hashes in the manifest if necessary, but prioritise simplicity in v1.

---

## 9. Testing and Guarantees

### 9.1 Deterministic Behaviour

1. Add tests for:

   - Repeated `dazzle generate` with identical spec and generator version, verifying:
     - Identical file contents in `app/generated` and `shared`.
     - Identical `dazzle_manifest.json`.

2. Add tests for:

   - Regeneration with `app/custom` populated, verifying:
     - No changes to `app/custom`.
     - Overrides (where present) are still routed correctly.

### 9.2 Safety Around User Changes

1. Test that:

   - Manual changes in `app/generated` are detected by `dazzle doctor`.
   - `dazzle regenerate` warns about these changes before overwriting.

2. Test that:

   - Adding or changing `ui_preferences` for a workspace results in:
     - A different layout plan.
     - Respectful handling of hidden/emphasised signals.

---

## 10. Documentation for DAZZLE Users

1. Provide a short “mental model” for users:

   - “If it’s structural, change the spec.”
   - “If it’s how something looks or behaves, change `custom/` or `ui_preferences`.”
   - “Regeneration will only overwrite `generated/` and `shared/`.”
   - “Use `dazzle doctor` to see if you’ve changed anything that will be overwritten.”

2. Provide explicit guidance for:

   - Creating a workspace override.
   - Adding custom components and wiring them into the registry.
   - Adjusting UI via `ui_preferences`.
   - When (and how) to use `dazzle capture-changes` to push code changes back into the DSL / AppSpec.

3. Keep documentation up to date with generator behaviour and CLI capabilities.

---

This specification should be used by DAZZLE’s implementation to:

- Enforce clear ownership boundaries between generated and user code.
- Enable safe regeneration of apps when the DSL / AppSpec changes.
- Provide a structured pathway for feedback and UI refinement without losing manual work.
