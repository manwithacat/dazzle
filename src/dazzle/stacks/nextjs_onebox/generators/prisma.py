"""
Prisma schema generator for Next.js Onebox.

Generates prisma/schema.prisma from entities.
"""

from pathlib import Path

from ....core import ir
from ...base.generator import Generator, GeneratorResult


class PrismaGenerator(Generator):
    """Generates Prisma schema from entities."""

    # Map DAZZLE field types to Prisma types
    TYPE_MAP = {
        ir.FieldTypeKind.STR: "String",
        ir.FieldTypeKind.TEXT: "String",
        ir.FieldTypeKind.INT: "Int",
        ir.FieldTypeKind.DECIMAL: "Decimal",
        ir.FieldTypeKind.BOOL: "Boolean",
        ir.FieldTypeKind.DATE: "DateTime",
        ir.FieldTypeKind.DATETIME: "DateTime",
        ir.FieldTypeKind.UUID: "String",
        ir.FieldTypeKind.EMAIL: "String",
        ir.FieldTypeKind.ENUM: "String",  # Will be converted to actual enum
        ir.FieldTypeKind.REF: "String",  # Will be converted to relation
    }

    def __init__(self, *args, **kwargs):
        """Initialize generator."""
        super().__init__(*args, **kwargs)
        # Relations cache: target_entity -> [(source_entity, field_name)]
        self._relations: dict[str, list[tuple[str, str]]] = {}

    def generate(self) -> GeneratorResult:
        """Generate Prisma schema."""
        result = GeneratorResult()

        schema = self._build_schema()

        path = self.output_dir / "prisma" / "schema.prisma"
        self._write_file(path, schema)
        result.add_file(path)

        # Store entity names for other generators
        result.add_artifact("entity_names", [e.name for e in self.spec.domain.entities])

        return result

    def _build_schema(self) -> str:
        """Build the complete Prisma schema."""
        lines = []

        # Datasource and generator
        lines.append('''// Prisma Schema
// Generated by DAZZLE Next.js Onebox Stack

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
''')

        # Check if DSL defines a User entity
        user_entity = next((e for e in self.spec.domain.entities if e.name.lower() == "user"), None)

        if user_entity:
            # Merge DSL User with auth User
            lines.append(self._build_merged_user_model(user_entity))
        else:
            # Built-in User model for auth
            lines.append(self._build_user_model())

        # Built-in Session model for auth
        lines.append(self._build_session_model())

        # Collect all relations for inverse relation generation
        self._relations = self._collect_relations()

        # Generate enums first
        for entity in self.spec.domain.entities:
            # Skip User if we merged it
            if user_entity and entity.name.lower() == "user":
                continue

            for field in entity.fields:
                if field.type.kind == ir.FieldTypeKind.ENUM and field.type.enum_values:
                    lines.append(self._build_enum(entity.name, field))

        # Generate models
        for entity in self.spec.domain.entities:
            # Skip User if we merged it
            if user_entity and entity.name.lower() == "user":
                continue

            lines.append(self._build_model(entity))

        return "\n".join(lines)

    def _collect_relations(self) -> dict:
        """Collect all relations for inverse relation generation."""
        relations = {}  # target_entity -> [(source_entity, field_name)]

        for entity in self.spec.domain.entities:
            for field in entity.fields:
                if field.type.kind == ir.FieldTypeKind.REF:
                    target = field.type.ref_entity
                    if target:
                        if target not in relations:
                            relations[target] = []
                        relations[target].append((entity.name, field.name))

        return relations

    def _build_user_model(self) -> str:
        """Build the built-in User model for auth."""
        return '''// Built-in User model for authentication
model User {
  id           String    @id @default(uuid())
  email        String    @unique
  passwordHash String
  name         String?
  role         String    @default("user")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  sessions     Session[]

  @@map("users")
}
'''

    def _build_merged_user_model(self, user_entity: ir.EntitySpec) -> str:
        """Build merged User model combining auth and DSL fields."""
        lines = [
            "// User model (auth + domain)",
            "model User {",
            "  // Auth fields",
            "  id           String    @id @default(uuid())",
            "  email        String    @unique",
            "  passwordHash String",
        ]

        # Add DSL fields (skip duplicates like id, email, timestamps)
        auth_fields = {"id", "email", "password_hash", "sessions", "created_at", "updated_at"}
        has_created_at = False
        has_updated_at = False

        for field in user_entity.fields:
            field_lower = field.name.lower()
            if field_lower not in auth_fields:
                field_line = self._build_field("User", field)
                # Indent properly
                lines.append(f"  {field_line}")
            elif field_lower == "created_at":
                has_created_at = True
            elif field_lower == "updated_at":
                has_updated_at = True

        # Add timestamps (if not already in DSL fields)
        if not has_created_at:
            lines.append("  createdAt    DateTime  @default(now())")
        if not has_updated_at:
            lines.append("  updatedAt    DateTime  @updatedAt")

        # Auth relations
        lines.append("")
        lines.append("  // Auth relations")
        lines.append("  sessions     Session[]")

        # Domain inverse relations
        if "User" in self._relations:
            lines.append("")
            lines.append("  // Domain relations (inverse)")
            for source_entity, field_name in self._relations["User"]:
                # Generate inverse relation
                relation_name = f"{source_entity}{field_name.title()}"
                field_plural = f"{self._camel_case(field_name)}{self._pascal_case(source_entity)}s"
                lines.append(f'  {field_plural} {self._pascal_case(source_entity)}[] @relation("{relation_name}")')

        lines.append("")
        lines.append('  @@map("users")')
        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _build_session_model(self) -> str:
        """Build the built-in Session model for auth."""
        return '''// Built-in Session model for authentication
model Session {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("sessions")
}
'''

    def _build_enum(self, entity_name: str, field: ir.FieldSpec) -> str:
        """Build a Prisma enum."""
        enum_name = f"{entity_name}{self._pascal_case(field.name)}"
        values = field.type.enum_values or []

        lines = [f"enum {enum_name} {{"]
        for value in values:
            # Use original casing from DSL to match TypeScript types
            # Just ensure it's a valid identifier (replace spaces/hyphens)
            enum_value = value.replace(" ", "_").replace("-", "_")
            lines.append(f"  {enum_value}")
        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _build_model(self, entity: ir.EntitySpec) -> str:
        """Build a Prisma model from an entity."""
        model_name = self._pascal_case(entity.name)
        lines = [f"model {model_name} {{"]

        # Build regular fields and collect relations
        relation_fields = []
        for field in entity.fields:
            if field.type.kind == ir.FieldTypeKind.REF:
                # Generate FK field + relation field
                fk_field, relation_field = self._build_relation_fields(entity.name, field)
                lines.append(f"  {fk_field}")
                relation_fields.append(relation_field)
            else:
                lines.append(f"  {self._build_field(entity.name, field)}")

        # Add relation fields after scalar fields
        if relation_fields:
            lines.append("")
            for rel_field in relation_fields:
                lines.append(f"  {rel_field}")

        # Add inverse relations
        if entity.name in self._relations:
            lines.append("")
            for source_entity, field_name in self._relations[entity.name]:
                # Generate inverse relation
                relation_name = f"{source_entity}{field_name.title()}"
                field_plural = f"{self._camel_case(field_name)}{self._pascal_case(source_entity)}s"
                lines.append(f'  {field_plural} {self._pascal_case(source_entity)}[] @relation("{relation_name}")')

        # Add indexes if defined (from constraints)
        index_constraints = [c for c in entity.constraints if c.kind == ir.ConstraintKind.INDEX]
        if index_constraints:
            lines.append("")
            for constraint in index_constraints:
                # Transform field names for relations (add Id suffix)
                transformed_fields = []
                for field_name in constraint.fields:
                    field = next((f for f in entity.fields if f.name == field_name), None)
                    if field and field.type.kind == ir.FieldTypeKind.REF:
                        transformed_fields.append(f"{self._camel_case(field_name)}Id")
                    else:
                        transformed_fields.append(self._camel_case(field_name))
                fields_str = ", ".join(transformed_fields)
                lines.append(f"  @@index([{fields_str}])")

        # Add table mapping
        table_name = entity.name.lower() + "s"
        lines.append(f'  @@map("{table_name}")')

        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _build_relation_fields(self, entity_name: str, field: ir.FieldSpec) -> tuple[str, str]:
        """Build FK field and relation field for a reference.

        Returns: (fk_field_line, relation_field_line)
        """
        field_name = self._camel_case(field.name)
        target_entity = self._pascal_case(field.type.ref_entity or "Unknown")

        # FK field
        fk_name = f"{field_name}Id"
        fk_type = "String"
        if not field.is_required:
            fk_type += "?"
        fk_modifiers = "@db.Uuid"
        fk_field = f"{fk_name} {fk_type} {fk_modifiers}"

        # Relation field
        relation_name = f"{entity_name}{field.name.title()}"
        rel_type = target_entity
        if not field.is_required:
            rel_type += "?"
        relation_field = f'{field_name} {rel_type} @relation("{relation_name}", fields: [{fk_name}], references: [id])'

        return fk_field, relation_field

    def _build_field(self, entity_name: str, field: ir.FieldSpec) -> str:
        """Build a Prisma field definition."""
        parts = [self._camel_case(field.name)]

        # Get Prisma type
        prisma_type = self._get_prisma_type(entity_name, field)
        parts.append(prisma_type)

        # Add modifiers
        modifiers = self._get_field_modifiers(field)
        if modifiers:
            parts.append(modifiers)

        return " ".join(parts)

    def _get_prisma_type(self, entity_name: str, field: ir.FieldSpec) -> str:
        """Get the Prisma type for a field."""
        field_type = field.type

        if field_type.kind == ir.FieldTypeKind.ENUM:
            # Use custom enum type
            return f"{entity_name}{self._pascal_case(field.name)}"

        if field_type.kind == ir.FieldTypeKind.REF:
            # Reference to another entity
            return self._pascal_case(field_type.ref_entity or "Unknown")

        # Basic type
        prisma_type = self.TYPE_MAP.get(field_type.kind, "String")

        # Make optional if not required and not pk
        if not field.is_required and not field.is_primary_key:
            prisma_type += "?"

        return prisma_type

    def _get_field_modifiers(self, field: ir.FieldSpec) -> str:
        """Get Prisma field modifiers."""
        modifiers = []

        if field.is_primary_key:
            modifiers.append("@id")
            if field.type.kind == ir.FieldTypeKind.UUID:
                modifiers.append("@default(uuid())")

        if field.is_unique:
            modifiers.append("@unique")

        if ir.FieldModifier.AUTO_ADD in field.modifiers:
            modifiers.append("@default(now())")

        if ir.FieldModifier.AUTO_UPDATE in field.modifiers:
            modifiers.append("@updatedAt")

        if field.default is not None and ir.FieldModifier.AUTO_ADD not in field.modifiers:
            default_value = self._format_default(field)
            if default_value:
                modifiers.append(f"@default({default_value})")

        # Add database type hints for specific types
        if field.type.kind == ir.FieldTypeKind.TEXT:
            modifiers.append("@db.Text")
        elif field.type.kind == ir.FieldTypeKind.UUID:
            modifiers.append("@db.Uuid")
        elif field.type.kind == ir.FieldTypeKind.STR and field.type.max_length:
            modifiers.append(f"@db.VarChar({field.type.max_length})")

        return " ".join(modifiers)

    def _format_default(self, field: ir.FieldSpec) -> str:
        """Format a default value for Prisma."""
        default = field.default
        if default is None:
            return ""

        if field.type.kind == ir.FieldTypeKind.BOOL:
            return "true" if default else "false"
        elif field.type.kind == ir.FieldTypeKind.INT:
            return str(default)
        elif field.type.kind == ir.FieldTypeKind.ENUM:
            # Use original casing to match enum definition and TypeScript types
            return str(default).replace(" ", "_").replace("-", "_")
        else:
            return f'"{default}"'

    def _pascal_case(self, name: str) -> str:
        """Convert to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _camel_case(self, name: str) -> str:
        """Convert to camelCase."""
        pascal = self._pascal_case(name)
        return pascal[0].lower() + pascal[1:] if pascal else ""
