"""
TypeScript types generator for Next.js Onebox.

Generates src/types/ with:
- entities.ts (entity types from IR)
- ux.ts (attention, persona, workspace types)
- api.ts (action response types)
"""

from pathlib import Path

from ....core import ir
from ...base.generator import Generator, GeneratorResult


class TypesGenerator(Generator):
    """Generates TypeScript types from IR."""

    # Map DAZZLE field types to TypeScript types
    TYPE_MAP = {
        ir.FieldTypeKind.STR: "string",
        ir.FieldTypeKind.TEXT: "string",
        ir.FieldTypeKind.INT: "number",
        ir.FieldTypeKind.DECIMAL: "number",
        ir.FieldTypeKind.BOOL: "boolean",
        ir.FieldTypeKind.DATE: "Date",
        ir.FieldTypeKind.DATETIME: "Date",
        ir.FieldTypeKind.UUID: "string",
        ir.FieldTypeKind.EMAIL: "string",
        ir.FieldTypeKind.ENUM: "string",  # Will be converted to union type
        ir.FieldTypeKind.REF: "string",  # ID reference
    }

    def generate(self) -> GeneratorResult:
        """Generate TypeScript type files."""
        result = GeneratorResult()

        self._generate_entity_types(result)
        self._generate_ux_types(result)
        self._generate_api_types(result)

        return result

    def _generate_entity_types(self, result: GeneratorResult) -> None:
        """Generate entity type definitions."""
        lines = [
            "// Entity Types",
            "// Generated by DAZZLE Next.js Onebox Stack",
            "",
        ]

        # Generate enum types first
        for entity in self.spec.domain.entities:
            for field in entity.fields:
                if field.type.kind == ir.FieldTypeKind.ENUM and field.type.enum_values:
                    enum_name = f"{self._pascal_case(entity.name)}{self._pascal_case(field.name)}"
                    values = " | ".join(f'"{v}"' for v in field.type.enum_values)
                    lines.append(f"export type {enum_name} = {values};")
                    lines.append("")

        # Generate entity interfaces
        for entity in self.spec.domain.entities:
            lines.append(self._build_entity_interface(entity))

        # Generate input types for create/update
        for entity in self.spec.domain.entities:
            lines.append(self._build_input_type(entity, "Create"))
            lines.append(self._build_input_type(entity, "Update"))

        path = self.output_dir / "src" / "types" / "entities.ts"
        self._write_file(path, "\n".join(lines))
        result.add_file(path)

    def _build_entity_interface(self, entity: ir.EntitySpec) -> str:
        """Build a TypeScript interface for an entity."""
        interface_name = self._pascal_case(entity.name)
        lines = [f"export interface {interface_name} {{"]

        for field in entity.fields:
            ts_type = self._get_ts_type(entity.name, field)

            # Field is optional if: not required, not primary key, and has no default
            # Fields with defaults are always present (database provides the value)
            has_default = field.default is not None or ir.FieldModifier.AUTO_ADD in field.modifiers or ir.FieldModifier.AUTO_UPDATE in field.modifiers
            optional = "?" if not field.is_required and not field.is_primary_key and not has_default else ""

            # For reference fields, use FK field name (e.g., ticketId not ticket)
            if field.type.kind == ir.FieldTypeKind.REF:
                field_name = f"{self._camel_case(field.name)}Id"
            else:
                field_name = self._camel_case(field.name)

            lines.append(f"  {field_name}{optional}: {ts_type};")

        # Add index signature for Mantine DataTable compatibility
        lines.append("  [key: string]: unknown;")

        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _build_input_type(self, entity: ir.EntitySpec, prefix: str) -> str:
        """Build input type for create/update operations."""
        type_name = f"{prefix}{self._pascal_case(entity.name)}Input"
        lines = [f"export interface {type_name} {{"]

        for field in entity.fields:
            # Skip auto-generated fields for input types
            if field.is_primary_key and field.type.kind == ir.FieldTypeKind.UUID:
                continue
            if ir.FieldModifier.AUTO_ADD in field.modifiers or ir.FieldModifier.AUTO_UPDATE in field.modifiers:
                continue

            ts_type = self._get_ts_type(entity.name, field)
            # All fields optional for Update, required fields only for Create
            optional = "?" if prefix == "Update" or not field.is_required else ""

            # For reference fields, use FK field name (e.g., ticketId not ticket)
            if field.type.kind == ir.FieldTypeKind.REF:
                field_name = f"{self._camel_case(field.name)}Id"
            else:
                field_name = self._camel_case(field.name)

            lines.append(f"  {field_name}{optional}: {ts_type};")

        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _get_ts_type(self, entity_name: str, field: ir.FieldSpec) -> str:
        """Get TypeScript type for a field."""
        if field.type.kind == ir.FieldTypeKind.ENUM and field.type.enum_values:
            return f"{self._pascal_case(entity_name)}{self._pascal_case(field.name)}"

        if field.type.kind == ir.FieldTypeKind.REF:
            return "string"  # ID reference

        return self.TYPE_MAP.get(field.type.kind, "string")

    def _generate_ux_types(self, result: GeneratorResult) -> None:
        """Generate UX-related types."""
        content = '''// UX Types
// Generated by DAZZLE Next.js Onebox Stack

/**
 * Attention signal levels for UI highlighting.
 */
export type AttentionLevel = "critical" | "warning" | "notice" | "info";

/**
 * Attention signal configuration.
 */
export interface AttentionSignal {
  level: AttentionLevel;
  message: string;
  condition?: string;
}

/**
 * Persona definition.
 */
export interface Persona {
  id: string;
  name: string;
  description?: string;
  scope?: string;
}

/**
 * Workspace region for dashboards.
 */
export interface WorkspaceRegion {
  id: string;
  name: string;
  source: string;
  filter?: string;
  sort?: string;
  limit?: number;
}

/**
 * Workspace definition.
 */
export interface Workspace {
  id: string;
  name: string;
  title: string;
  purpose?: string;
  regions: WorkspaceRegion[];
}

/**
 * Surface field configuration with UX attributes.
 */
export interface SurfaceField {
  name: string;
  label?: string;
  type: string;
  required?: boolean;
  readonly?: boolean;
  hidden?: boolean;
}

/**
 * Surface action button.
 */
export interface SurfaceAction {
  id: string;
  label: string;
  variant?: "primary" | "secondary" | "danger";
  href?: string;
  onClick?: string;
}
'''
        path = self.output_dir / "src" / "types" / "ux.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_api_types(self, result: GeneratorResult) -> None:
        """Generate API response types."""
        content = '''// API Types
// Generated by DAZZLE Next.js Onebox Stack

/**
 * Standard action response.
 */
export interface ActionResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  errors?: Record<string, string[]>;
}

/**
 * Paginated list response.
 */
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

/**
 * Authentication user.
 */
export interface AuthUser {
  id: string;
  email: string;
  name?: string;
  role: string;
}

/**
 * Session data.
 */
export interface Session {
  user: AuthUser;
  expiresAt: Date;
}
'''
        path = self.output_dir / "src" / "types" / "api.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _pascal_case(self, name: str) -> str:
        """Convert to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _camel_case(self, name: str) -> str:
        """Convert to camelCase."""
        pascal = self._pascal_case(name)
        return pascal[0].lower() + pascal[1:] if pascal else ""
