# type: ignore
"""
Server Actions generator for Next.js Onebox.

Generates src/actions/ with CRUD actions for each entity.
"""

from ....core import ir
from ...base.generator import Generator, GeneratorResult


class ActionsGenerator(Generator):
    """Generates Server Actions for CRUD operations."""

    def generate(self) -> GeneratorResult:
        """Generate action files for each entity."""
        result = GeneratorResult()

        # Generate actions for each entity
        for entity in self.spec.domain.entities:
            self._generate_entity_actions(entity, result)

        # Generate index file
        self._generate_actions_index(result)

        return result

    def _generate_entity_actions(self, entity: ir.EntitySpec, result: GeneratorResult) -> None:
        """Generate CRUD actions for an entity."""
        entity_name = entity.name
        pascal_name = self._pascal_case(entity_name)
        camel_name = self._camel_case(entity_name)
        snake_name = entity_name.lower()

        # Build field lists
        pk_field = next((f for f in entity.fields if f.is_primary_key), None)
        pk_name = self._camel_case(pk_field.name) if pk_field else "id"

        content = f"""// {pascal_name} Server Actions
// Generated by DAZZLE Next.js Onebox Stack

"use server";

import {{ revalidatePath }} from "next/cache";
import {{ prisma }} from "@/lib/db";
import type {{ {pascal_name}, Create{pascal_name}Input, Update{pascal_name}Input }} from "@/types/entities";
import type {{ ActionResponse, PaginatedResponse }} from "@/types/api";

/**
 * Get all {camel_name}s with optional pagination.
 */
export async function get{pascal_name}s(options?: {{
  page?: number;
  pageSize?: number;
  orderBy?: string;
  orderDir?: "asc" | "desc";
}}): Promise<PaginatedResponse<{pascal_name}>> {{
  const page = options?.page || 1;
  const pageSize = options?.pageSize || 10;
  const skip = (page - 1) * pageSize;

  const orderBy = options?.orderBy
    ? {{ [options.orderBy]: options?.orderDir || "asc" }}
    : undefined;

  const [items, total] = await Promise.all([
    prisma.{camel_name}.findMany({{
      skip,
      take: pageSize,
      orderBy,
    }}),
    prisma.{camel_name}.count(),
  ]);

  return {{
    items: items as {pascal_name}[],
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  }};
}}

/**
 * Get a single {camel_name} by ID.
 */
export async function get{pascal_name}(
  {pk_name}: string
): Promise<{pascal_name} | null> {{
  const item = await prisma.{camel_name}.findUnique({{
    where: {{ {pk_name} }},
  }});

  return item as {pascal_name} | null;
}}

/**
 * Create a new {camel_name}.
 */
export async function create{pascal_name}(
  data: Create{pascal_name}Input
): Promise<ActionResponse<{pascal_name}>> {{
  try {{
    const item = await prisma.{camel_name}.create({{
      data,
    }});

    revalidatePath("/{snake_name}s");

    return {{
      success: true,
      data: item as {pascal_name},
    }};
  }} catch (error) {{
    console.error("Error creating {camel_name}:", error);
    return {{
      success: false,
      error: error instanceof Error ? error.message : "Failed to create {camel_name}",
    }};
  }}
}}

/**
 * Update a {camel_name}.
 */
export async function update{pascal_name}(
  {pk_name}: string,
  data: Update{pascal_name}Input
): Promise<ActionResponse<{pascal_name}>> {{
  try {{
    const item = await prisma.{camel_name}.update({{
      where: {{ {pk_name} }},
      data,
    }});

    revalidatePath("/{snake_name}s");
    revalidatePath(`/{snake_name}s/${{{pk_name}}}`);

    return {{
      success: true,
      data: item as {pascal_name},
    }};
  }} catch (error) {{
    console.error("Error updating {camel_name}:", error);
    return {{
      success: false,
      error: error instanceof Error ? error.message : "Failed to update {camel_name}",
    }};
  }}
}}

/**
 * Delete a {camel_name}.
 */
export async function delete{pascal_name}(
  {pk_name}: string
): Promise<ActionResponse<void>> {{
  try {{
    await prisma.{camel_name}.delete({{
      where: {{ {pk_name} }},
    }});

    revalidatePath("/{snake_name}s");

    return {{
      success: true,
    }};
  }} catch (error) {{
    console.error("Error deleting {camel_name}:", error);
    return {{
      success: false,
      error: error instanceof Error ? error.message : "Failed to delete {camel_name}",
    }};
  }}
}}

/**
 * Search {camel_name}s by a query string.
 */
export async function search{pascal_name}s(
  query: string,
  options?: {{
    page?: number;
    pageSize?: number;
  }}
): Promise<PaginatedResponse<{pascal_name}>> {{
  const page = options?.page || 1;
  const pageSize = options?.pageSize || 10;
  const skip = (page - 1) * pageSize;

  // Build search conditions for text fields
  const searchConditions = {{
    OR: [
{self._build_search_conditions(entity)}
    ],
  }};

  const [items, total] = await Promise.all([
    prisma.{camel_name}.findMany({{
      where: searchConditions,
      skip,
      take: pageSize,
    }}),
    prisma.{camel_name}.count({{
      where: searchConditions,
    }}),
  ]);

  return {{
    items: items as {pascal_name}[],
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  }};
}}
"""
        path = self.output_dir / "src" / "actions" / f"{snake_name}.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _build_search_conditions(self, entity: ir.EntitySpec) -> str:
        """Build Prisma search conditions for text fields."""
        conditions = []
        for field in entity.fields:
            if field.type.kind in (
                ir.FieldTypeKind.STR,
                ir.FieldTypeKind.TEXT,
                ir.FieldTypeKind.EMAIL,
            ):
                field_name = self._camel_case(field.name)
                conditions.append(
                    f'      {{ {field_name}: {{ contains: query, mode: "insensitive" as const }} }},'
                )

        return "\n".join(conditions) if conditions else "      // No searchable text fields"

    def _generate_actions_index(self, result: GeneratorResult) -> None:
        """Generate actions index file."""
        exports = []
        for entity in self.spec.domain.entities:
            snake_name = entity.name.lower()
            pascal_name = self._pascal_case(entity.name)
            exports.append(
                f'export {{ get{pascal_name}s, get{pascal_name}, create{pascal_name}, update{pascal_name}, delete{pascal_name}, search{pascal_name}s }} from "./{snake_name}";'
            )

        content = f"""// Server Actions Index
// Generated by DAZZLE Next.js Onebox Stack

{chr(10).join(exports)}
"""
        path = self.output_dir / "src" / "actions" / "index.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _pascal_case(self, name: str) -> str:
        """Convert to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _camel_case(self, name: str) -> str:
        """Convert to camelCase."""
        pascal = self._pascal_case(name)
        return pascal[0].lower() + pascal[1:] if pascal else ""
