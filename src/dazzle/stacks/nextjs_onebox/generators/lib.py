"""
Library generator for Next.js Onebox.

Generates src/lib/ with:
- db.ts (Prisma client singleton)
- auth.ts (authentication utilities)
- persona.ts (persona detection and switching)
- attention.ts (attention signal utilities)
- utils.ts (general utilities)
"""

from ...base.generator import Generator, GeneratorResult


class LibGenerator(Generator):
    """Generates utility library files."""

    def generate(self) -> GeneratorResult:
        """Generate library files."""
        result = GeneratorResult()

        self._generate_db(result)
        self._generate_auth(result)
        self._generate_persona(result)
        self._generate_attention(result)
        self._generate_utils(result)

        return result

    def _generate_db(self, result: GeneratorResult) -> None:
        """Generate Prisma client singleton."""
        content = """// Database Client
// Generated by DAZZLE Next.js Onebox Stack

import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = prisma;
}

export default prisma;
"""
        path = self.output_dir / "src" / "lib" / "db.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_auth(self, result: GeneratorResult) -> None:
        """Generate authentication utilities."""
        content = """// Authentication Utilities
// Generated by DAZZLE Next.js Onebox Stack

import { cookies } from "next/headers";
import { SignJWT, jwtVerify } from "jose";
import { compare, hash } from "bcryptjs";
import { prisma } from "./db";
import type { AuthUser, Session } from "@/types/api";

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || "your-secret-key-change-in-production"
);

const SESSION_COOKIE = "session";
const SESSION_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days

/**
 * Hash a password using bcrypt.
 */
export async function hashPassword(password: string): Promise<string> {
  return hash(password, 12);
}

/**
 * Verify a password against a hash.
 */
export async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  return compare(password, hashedPassword);
}

/**
 * Create a JWT token.
 */
async function createToken(payload: Record<string, unknown>): Promise<string> {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: "HS256" })
    .setIssuedAt()
    .setExpirationTime("7d")
    .sign(JWT_SECRET);
}

/**
 * Verify a JWT token.
 */
async function verifyToken(token: string): Promise<Record<string, unknown> | null> {
  try {
    const { payload } = await jwtVerify(token, JWT_SECRET);
    return payload as Record<string, unknown>;
  } catch {
    return null;
  }
}

/**
 * Create a session for a user.
 */
export async function createSession(userId: string): Promise<string> {
  const expiresAt = new Date(Date.now() + SESSION_DURATION);

  // Create session in database
  const session = await prisma.session.create({
    data: {
      userId,
      expiresAt,
    },
  });

  // Create JWT with session ID
  const token = await createToken({
    sessionId: session.id,
    userId,
  });

  // Set cookie
  const cookieStore = await cookies();
  cookieStore.set(SESSION_COOKIE, token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    expires: expiresAt,
    path: "/",
  });

  return session.id;
}

/**
 * Get the current session.
 */
export async function getSession(): Promise<Session | null> {
  const cookieStore = await cookies();
  const token = cookieStore.get(SESSION_COOKIE)?.value;

  if (!token) {
    return null;
  }

  const payload = await verifyToken(token);
  if (!payload || !payload.sessionId) {
    return null;
  }

  // Get session from database
  const session = await prisma.session.findUnique({
    where: { id: payload.sessionId as string },
    include: { user: true },
  });

  if (!session || session.expiresAt < new Date()) {
    // Session expired or not found
    await destroySession();
    return null;
  }

  return {
    user: {
      id: session.user.id,
      email: session.user.email,
      name: session.user.name || undefined,
      role: session.user.role,
    },
    expiresAt: session.expiresAt,
  };
}

/**
 * Get the current user.
 */
export async function getCurrentUser(): Promise<AuthUser | null> {
  const session = await getSession();
  return session?.user || null;
}

/**
 * Require authentication (throws if not authenticated).
 */
export async function requireAuth(): Promise<AuthUser> {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error("Unauthorized");
  }
  return user;
}

/**
 * Destroy the current session.
 */
export async function destroySession(): Promise<void> {
  const cookieStore = await cookies();
  const token = cookieStore.get(SESSION_COOKIE)?.value;

  if (token) {
    const payload = await verifyToken(token);
    if (payload?.sessionId) {
      // Delete session from database
      await prisma.session.delete({
        where: { id: payload.sessionId as string },
      }).catch(() => {
        // Ignore if session doesn't exist
      });
    }
  }

  // Clear cookie
  cookieStore.delete(SESSION_COOKIE);
}

/**
 * Sign up a new user.
 */
export async function signUp(
  email: string,
  password: string,
  name?: string
): Promise<AuthUser> {
  // Check if user already exists
  const existing = await prisma.user.findUnique({
    where: { email },
  });

  if (existing) {
    throw new Error("Email already in use");
  }

  // Hash password and create user
  const passwordHash = await hashPassword(password);
  const user = await prisma.user.create({
    data: {
      email,
      passwordHash,
      name,
    },
  });

  // Create session
  await createSession(user.id);

  return {
    id: user.id,
    email: user.email,
    name: user.name || undefined,
    role: user.role,
  };
}

/**
 * Sign in a user.
 */
export async function signIn(
  email: string,
  password: string
): Promise<AuthUser> {
  const user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    throw new Error("Invalid email or password");
  }

  const valid = await verifyPassword(password, user.passwordHash);
  if (!valid) {
    throw new Error("Invalid email or password");
  }

  // Create session
  await createSession(user.id);

  return {
    id: user.id,
    email: user.email,
    name: user.name || undefined,
    role: user.role,
  };
}

/**
 * Sign out the current user.
 */
export async function signOut(): Promise<void> {
  await destroySession();
}
"""
        path = self.output_dir / "src" / "lib" / "auth.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_persona(self, result: GeneratorResult) -> None:
        """Generate persona utilities."""
        # Extract personas from surfaces and workspaces that have persona variants
        personas_seen = set()
        persona_defs = []

        # Extract from surfaces
        for surface in self.spec.surfaces:
            if surface.ux and surface.ux.persona_variants:
                for variant in surface.ux.persona_variants:
                    if variant.persona not in personas_seen:
                        personas_seen.add(variant.persona)
                        scope_str = f'"{variant.scope}"' if variant.scope else "undefined"
                        persona_defs.append(
                            f'  {{ id: "{variant.persona}", name: "{variant.persona.replace("_", " ").title()}", '
                            f'description: "", scope: {scope_str} }}'
                        )

        # Extract from workspaces
        for workspace in self.spec.workspaces:
            if workspace.ux and workspace.ux.persona_variants:
                for variant in workspace.ux.persona_variants:
                    if variant.persona not in personas_seen:
                        personas_seen.add(variant.persona)
                        scope_str = f'"{variant.scope}"' if variant.scope else "undefined"
                        persona_defs.append(
                            f'  {{ id: "{variant.persona}", name: "{variant.persona.replace("_", " ").title()}", '
                            f'description: "", scope: {scope_str} }}'
                        )

        personas_array = ",\n".join(persona_defs) if persona_defs else ""

        content = f"""// Persona Utilities
// Generated by DAZZLE Next.js Onebox Stack

import {{ cookies }} from "next/headers";
import type {{ Persona }} from "@/types/ux";

const PERSONA_COOKIE = "persona";

/**
 * Available personas defined in the app.
 */
export const personas: Persona[] = [
{personas_array}
];

/**
 * Get the current persona from cookies.
 */
export async function getCurrentPersona(): Promise<Persona | null> {{
  const cookieStore = await cookies();
  const personaId = cookieStore.get(PERSONA_COOKIE)?.value;

  if (!personaId) {{
    return personas[0] || null; // Default to first persona
  }}

  return personas.find((p) => p.id === personaId) || personas[0] || null;
}}

/**
 * Set the current persona.
 */
export async function setCurrentPersona(personaId: string): Promise<void> {{
  const cookieStore = await cookies();
  const persona = personas.find((p) => p.id === personaId);

  if (persona) {{
    cookieStore.set(PERSONA_COOKIE, personaId, {{
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 30, // 30 days
      path: "/",
    }});
  }}
}}

/**
 * Get the persona's data scope filter.
 */
export function getPersonaScope(persona: Persona | null): string | null {{
  return persona?.scope || null;
}}

/**
 * Check if a persona can access an item based on scope.
 */
export function canAccessItem(
  persona: Persona | null,
  item: Record<string, unknown>
): boolean {{
  const scope = persona?.scope;
  if (!scope) {{
    return true; // No scope means access to everything
  }}

  // Simple scope matching - can be extended for complex rules
  // Example scope: "department = sales"
  const match = scope.match(/^(\\w+)\\s*=\\s*(.+)$/);
  if (match) {{
    const [, field, value] = match;
    return String(item[field]).toLowerCase() === value.toLowerCase();
  }}

  return true;
}}
"""
        path = self.output_dir / "src" / "lib" / "persona.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_attention(self, result: GeneratorResult) -> None:
        """Generate attention signal utilities."""
        content = """// Attention Signal Utilities
// Generated by DAZZLE Next.js Onebox Stack

import type { AttentionLevel, AttentionSignal } from "@/types/ux";

/**
 * Attention level styles for Tailwind.
 */
export const attentionStyles: Record<AttentionLevel, {
  bg: string;
  border: string;
  text: string;
  icon: string;
}> = {
  critical: {
    bg: "bg-red-50",
    border: "border-red-500",
    text: "text-red-800",
    icon: "text-red-500",
  },
  warning: {
    bg: "bg-amber-50",
    border: "border-amber-500",
    text: "text-amber-800",
    icon: "text-amber-500",
  },
  notice: {
    bg: "bg-blue-50",
    border: "border-blue-500",
    text: "text-blue-800",
    icon: "text-blue-500",
  },
  info: {
    bg: "bg-slate-50",
    border: "border-slate-300",
    text: "text-slate-700",
    icon: "text-slate-500",
  },
};

/**
 * Evaluate an attention signal condition against an item.
 */
export function evaluateCondition(
  condition: string,
  item: Record<string, unknown>
): boolean {
  // Parse simple conditions like "status = overdue" or "priority = high"
  const match = condition.match(/^(\\w+)\\s*(=|!=|>|<|>=|<=)\\s*(.+)$/);

  if (!match) {
    return false;
  }

  const [, field, operator, value] = match;
  const itemValue = item[field];
  const compareValue = value.replace(/^["']|["']$/g, ""); // Remove quotes

  switch (operator) {
    case "=":
      return String(itemValue).toLowerCase() === compareValue.toLowerCase();
    case "!=":
      return String(itemValue).toLowerCase() !== compareValue.toLowerCase();
    case ">":
      return Number(itemValue) > Number(compareValue);
    case "<":
      return Number(itemValue) < Number(compareValue);
    case ">=":
      return Number(itemValue) >= Number(compareValue);
    case "<=":
      return Number(itemValue) <= Number(compareValue);
    default:
      return false;
  }
}

/**
 * Get attention signals that apply to an item.
 */
export function getAttentionSignals(
  signals: AttentionSignal[],
  item: Record<string, unknown>
): AttentionSignal[] {
  return signals.filter((signal) => {
    if (!signal.condition) {
      return true; // No condition means always show
    }
    return evaluateCondition(signal.condition, item);
  });
}

/**
 * Get the highest priority attention signal for an item.
 */
export function getHighestAttention(
  signals: AttentionSignal[],
  item: Record<string, unknown>
): AttentionSignal | null {
  const applicable = getAttentionSignals(signals, item);

  if (applicable.length === 0) {
    return null;
  }

  // Priority order: critical > warning > notice > info
  const priority: AttentionLevel[] = ["critical", "warning", "notice", "info"];

  for (const level of priority) {
    const signal = applicable.find((s) => s.level === level);
    if (signal) {
      return signal;
    }
  }

  return applicable[0];
}

/**
 * Get Tailwind classes for an attention level.
 */
export function getAttentionClasses(level: AttentionLevel): string {
  const styles = attentionStyles[level];
  return `${styles.bg} ${styles.border} ${styles.text} border-l-4 p-3`;
}
"""
        path = self.output_dir / "src" / "lib" / "attention.ts"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_utils(self, result: GeneratorResult) -> None:
        """Generate general utilities."""
        content = """// General Utilities
// Generated by DAZZLE Next.js Onebox Stack

import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Merge Tailwind classes with clsx.
 */
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

/**
 * Format a date for display.
 */
export function formatDate(date: Date | string | null): string {
  if (!date) return "";
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}

/**
 * Format a datetime for display.
 */
export function formatDateTime(date: Date | string | null): string {
  if (!date) return "";
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toLocaleString("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}

/**
 * Truncate text to a maximum length.
 */
export function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + "...";
}

/**
 * Convert to title case.
 */
export function toTitleCase(str: string): string {
  return str
    .split(/[_\\s-]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
}

/**
 * Convert to camelCase.
 */
export function toCamelCase(str: string): string {
  return str
    .split(/[_\\s-]+/)
    .map((word, index) =>
      index === 0
        ? word.toLowerCase()
        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    )
    .join("");
}

/**
 * Convert to PascalCase.
 */
export function toPascalCase(str: string): string {
  return str
    .split(/[_\\s-]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

/**
 * Convert to snake_case.
 */
export function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, "_$1")
    .toLowerCase()
    .replace(/^_/, "")
    .replace(/[\\s-]+/g, "_");
}

/**
 * Sleep for a given number of milliseconds.
 */
export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Check if a value is empty.
 */
export function isEmpty(value: unknown): boolean {
  if (value === null || value === undefined) return true;
  if (typeof value === "string") return value.trim() === "";
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === "object") return Object.keys(value).length === 0;
  return false;
}
"""
        path = self.output_dir / "src" / "lib" / "utils.ts"
        self._write_file(path, content)
        result.add_file(path)
