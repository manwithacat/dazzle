# type: ignore
"""
Pages generator for Next.js Onebox.

Generates src/app/ pages from surfaces:
- List surfaces → page.tsx with DataTable
- Detail surfaces → [id]/page.tsx
- Create surfaces → new/page.tsx
- Edit surfaces → [id]/edit/page.tsx
- Dashboard surfaces → page.tsx with regions
"""

from pathlib import Path

from ....core import ir
from ...base.generator import Generator, GeneratorResult


class PagesGenerator(Generator):
    """Generates App Router pages from surfaces."""

    def generate(self) -> GeneratorResult:
        """Generate page files from surfaces."""
        result = GeneratorResult()

        # Generate home page
        self._generate_home_page(result)

        # Generate pages for each surface
        for surface in self.spec.surfaces:
            if surface.mode == ir.SurfaceMode.LIST:
                self._generate_list_page(surface, result)
            elif surface.mode == ir.SurfaceMode.VIEW:
                self._generate_detail_page(surface, result)
            elif surface.mode == ir.SurfaceMode.CREATE:
                self._generate_create_page(surface, result)
            elif surface.mode == ir.SurfaceMode.EDIT:
                self._generate_edit_page(surface, result)

        return result

    def _generate_home_page(self, result: GeneratorResult) -> None:
        """Generate home page."""
        app_title = self.spec.title or self.spec.name

        # Find first list surface for redirect or show welcome
        list_surfaces = [s for s in self.spec.surfaces if s.mode == ir.SurfaceMode.LIST]
        redirect_target = f"/{list_surfaces[0].name.lower()}" if list_surfaces else None

        if redirect_target:
            content = f'''// Home Page (Redirect)
// Generated by DAZZLE Next.js Onebox Stack

import {{ redirect }} from "next/navigation";

export default function HomePage() {{
  redirect("{redirect_target}");
}}
'''
        else:
            content = f'''// Home Page
// Generated by DAZZLE Next.js Onebox Stack

import {{ getCurrentUser }} from "@/lib/auth";
import {{ Nav }} from "@/components/nav";
import {{ Card, CardHeader, CardTitle, CardContent }} from "@/components/ui/card";

export default async function HomePage() {{
  const user = await getCurrentUser();

  return (
    <div className="min-h-screen bg-gray-50">
      <Nav user={{user}} />
      <main className="page-container">
        <Card>
          <CardHeader>
            <CardTitle>Welcome to {app_title}</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-gray-600">
              This application was generated with DAZZLE.
            </p>
          </CardContent>
        </Card>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_list_page(self, surface: ir.SurfaceSpec, result: GeneratorResult) -> None:
        """Generate list page with DataTable."""
        snake_name = surface.name.lower()
        entity_name = surface.entity_ref or snake_name.rstrip("s")
        pascal_entity = self._pascal_case(entity_name)
        title = surface.title or surface.name.replace("_", " ").title()

        # Get entity fields
        entity = self._get_entity(entity_name)
        if not entity:
            return

        # Build columns from entity fields
        columns = self._build_table_columns(entity, surface)

        # Get UX configuration
        ux_block = surface.ux
        empty_message = ux_block.empty_message if ux_block and ux_block.empty_message else f"No {entity_name}s found"

        content = f'''// {title} List Page
// Generated by DAZZLE Next.js Onebox Stack

import Link from "next/link";
import {{ Plus }} from "lucide-react";
import {{ getCurrentUser }} from "@/lib/auth";
import {{ get{pascal_entity}s }} from "@/actions/{entity_name.lower()}";
import {{ Nav }} from "@/components/nav";
import {{ Button }} from "@/components/ui/button";
import {{ {pascal_entity}Table }} from "./_components/table";

interface PageProps {{
  searchParams: Promise<{{
    page?: string;
    sort?: string;
    dir?: string;
  }}>
}}

export default async function {pascal_entity}ListPage({{ searchParams }}: PageProps) {{
  const user = await getCurrentUser();
  const params = await searchParams;
  const page = parseInt(params.page || "1", 10);
  const sort = params.sort;
  const dir = params.dir as "asc" | "desc" | undefined;

  const data = await get{pascal_entity}s({{
    page,
    pageSize: 10,
    orderBy: sort,
    orderDir: dir,
  }});

  return (
    <div className="min-h-screen bg-gray-50">
      <Nav user={{user}} />
      <main className="page-container">
        <div className="page-header">
          <h1>{title}</h1>
          <Button asChild>
            <Link href="/{entity_name}s/new">
              <Plus className="mr-2 h-4 w-4" />
              New {pascal_entity}
            </Link>
          </Button>
        </div>

        <div className="table-container">
          <{pascal_entity}Table
            data={{data}}
            emptyMessage="{empty_message}"
            entityPath="{entity_name}s"
          />
        </div>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / snake_name / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

        # Generate table component
        self._generate_table_component(entity, surface, columns, result)

    def _generate_table_component(
        self,
        entity: ir.EntitySpec,
        surface: ir.SurfaceSpec,
        columns: list[dict],
        result: GeneratorResult,
    ) -> None:
        """Generate table component for list page."""
        snake_name = surface.name.lower()
        entity_name = entity.name
        pascal_entity = self._pascal_case(entity_name)

        # Build column definitions
        column_defs = []
        for col in columns:
            accessor = col["accessor"]
            title = col["title"]
            sortable = col.get("sortable", True)
            field_type = col.get("field_type")

            # Add render function for Date and Boolean fields
            if field_type == ir.FieldTypeKind.DATE or field_type == ir.FieldTypeKind.DATETIME:
                column_defs.append(
                    f'    {{ accessor: "{accessor}", title: "{title}", sortable: {str(sortable).lower()}, '
                    f'render: (record) => record.{accessor} ? new Date(record.{accessor}).toLocaleDateString() : "-" }},'
                )
            elif field_type == ir.FieldTypeKind.BOOL:
                column_defs.append(
                    f'    {{ accessor: "{accessor}", title: "{title}", sortable: {str(sortable).lower()}, '
                    f'render: (record) => record.{accessor} ? "Yes" : "No" }},'
                )
            else:
                column_defs.append(
                    f'    {{ accessor: "{accessor}", title: "{title}", sortable: {str(sortable).lower()} }},'
                )
        columns_str = "\n".join(column_defs)

        content = f'''"use client";

// {pascal_entity} Table Component
// Generated by DAZZLE Next.js Onebox Stack

import {{ useRouter, useSearchParams }} from "next/navigation";
import {{ DataTable, type DataTableColumn, type DataTableSortStatus }} from "@/components/data-table";
import {{ EmptyState }} from "@/components/empty-state";
import type {{ {pascal_entity} }} from "@/types/entities";
import type {{ PaginatedResponse }} from "@/types/api";

interface {pascal_entity}TableProps {{
  data: PaginatedResponse<{pascal_entity}>;
  emptyMessage?: string;
  entityPath: string;
}}

export function {pascal_entity}Table({{ data, emptyMessage, entityPath }}: {pascal_entity}TableProps) {{
  const router = useRouter();
  const searchParams = useSearchParams();

  const columns: DataTableColumn<{pascal_entity}>[] = [
{columns_str}
  ];

  const handlePageChange = (page: number) => {{
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());
    router.push(`/{snake_name}?${{params.toString()}}`);
  }};

  const handleSortChange = (status: DataTableSortStatus<{pascal_entity}>) => {{
    const params = new URLSearchParams(searchParams.toString());
    params.set("sort", String(status.columnAccessor));
    params.set("dir", status.direction);
    params.delete("page");
    router.push(`/{snake_name}?${{params.toString()}}`);
  }};

  const handleRowClick = (record: {pascal_entity}) => {{
    router.push(`/${{entityPath}}/${{record.id}}`);
  }};

  if (data.items.length === 0) {{
    return (
      <EmptyState
        message={{emptyMessage || "No items found"}}
        action={{{{
          label: "Create New",
          href: `/${{entityPath}}/new`,
        }}}}
      />
    );
  }}

  return (
    <DataTable
      records={{data.items}}
      columns={{columns}}
      totalRecords={{data.total}}
      recordsPerPage={{data.pageSize}}
      page={{data.page}}
      onPageChange={{handlePageChange}}
      onRowClick={{handleRowClick}}
      sortStatus={{
        searchParams.get("sort")
          ? {{
              columnAccessor: searchParams.get("sort")!,
              direction: (searchParams.get("dir") as "asc" | "desc") || "asc",
            }}
          : undefined
      }}
      onSortStatusChange={{handleSortChange}}
    />
  );
}}
'''
        path = self.output_dir / "src" / "app" / snake_name / "_components" / "table.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_detail_page(self, surface: ir.SurfaceSpec, result: GeneratorResult) -> None:
        """Generate detail page."""
        # Infer entity name from surface name (e.g., "task_detail" -> "task")
        snake_name = surface.name.lower().replace("_detail", "").replace("_view", "")
        entity_name = surface.entity_ref or snake_name
        pascal_entity = self._pascal_case(entity_name)
        title = surface.title or f"{pascal_entity} Details"

        entity = self._get_entity(entity_name)
        if not entity:
            return

        # Build field displays
        field_displays = self._build_detail_fields(entity, surface)

        content = f'''// {title} Page
// Generated by DAZZLE Next.js Onebox Stack

import Link from "next/link";
import {{ notFound }} from "next/navigation";
import {{ ArrowLeft, Pencil, Trash2 }} from "lucide-react";
import {{ getCurrentUser }} from "@/lib/auth";
import {{ get{pascal_entity}, delete{pascal_entity} }} from "@/actions/{entity_name.lower()}";
import {{ Nav }} from "@/components/nav";
import {{ Button }} from "@/components/ui/button";
import {{ Card, CardHeader, CardTitle, CardContent }} from "@/components/ui/card";
import {{ DeleteButton }} from "./_components/delete-button";

interface PageProps {{
  params: Promise<{{ id: string }}>;
}}

export default async function {pascal_entity}DetailPage({{ params }}: PageProps) {{
  const user = await getCurrentUser();
  const {{ id }} = await params;
  const item = await get{pascal_entity}(id);

  if (!item) {{
    notFound();
  }}

  return (
    <div className="min-h-screen bg-gray-50">
      <Nav user={{user}} />
      <main className="page-container">
        <div className="mb-6">
          <Link
            href="/{snake_name}s"
            className="inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to list
          </Link>
        </div>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle>{title}</CardTitle>
            <div className="action-bar">
              <Button variant="secondary" asChild>
                <Link href={{`/{snake_name}s/${{id}}/edit`}}>
                  <Pencil className="mr-2 h-4 w-4" />
                  Edit
                </Link>
              </Button>
              <DeleteButton id={{id}} />
            </div>
          </CardHeader>
          <CardContent>
            <dl className="grid gap-4 sm:grid-cols-2">
{field_displays}
            </dl>
          </CardContent>
        </Card>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / f"{snake_name}s" / "[id]" / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

        # Generate delete button component
        self._generate_delete_button(entity_name, snake_name, result)

    def _generate_delete_button(self, entity_name: str, snake_name: str, result: GeneratorResult) -> None:
        """Generate delete button component."""
        pascal_entity = self._pascal_case(entity_name)

        content = f'''"use client";

// Delete Button Component
// Generated by DAZZLE Next.js Onebox Stack

import {{ useState, useTransition }} from "react";
import {{ useRouter }} from "next/navigation";
import {{ Trash2 }} from "lucide-react";
import {{ delete{pascal_entity} }} from "@/actions/{entity_name.lower()}";
import {{ Button }} from "@/components/ui/button";

interface DeleteButtonProps {{
  id: string;
}}

export function DeleteButton({{ id }}: DeleteButtonProps) {{
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [showConfirm, setShowConfirm] = useState(false);

  const handleDelete = () => {{
    startTransition(async () => {{
      const result = await delete{pascal_entity}(id);
      if (result.success) {{
        router.push("/{snake_name}s");
      }}
    }});
  }};

  if (showConfirm) {{
    return (
      <div className="flex items-center gap-2">
        <span className="text-sm text-gray-600">Delete?</span>
        <Button
          variant="danger"
          size="sm"
          onClick={{handleDelete}}
          disabled={{isPending}}
        >
          {{isPending ? "Deleting..." : "Yes"}}
        </Button>
        <Button
          variant="secondary"
          size="sm"
          onClick={{() => setShowConfirm(false)}}
          disabled={{isPending}}
        >
          No
        </Button>
      </div>
    );
  }}

  return (
    <Button variant="danger" onClick={{() => setShowConfirm(true)}}>
      <Trash2 className="mr-2 h-4 w-4" />
      Delete
    </Button>
  );
}}
'''
        path = self.output_dir / "src" / "app" / f"{snake_name}s" / "[id]" / "_components" / "delete-button.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_create_page(self, surface: ir.SurfaceSpec, result: GeneratorResult) -> None:
        """Generate create page."""
        snake_name = surface.name.lower().replace("_create", "").replace("_new", "")
        entity_name = surface.entity_ref or snake_name
        pascal_entity = self._pascal_case(entity_name)
        title = surface.title or f"Create {pascal_entity}"

        entity = self._get_entity(entity_name)
        if not entity:
            return

        # Build form fields
        form_fields = self._build_form_fields(entity, surface, is_create=True)

        content = f'''"use client";

// {title} Page
// Generated by DAZZLE Next.js Onebox Stack

import {{ useFormState }} from "react-dom";
import {{ useFormStatus }} from "react-dom";
import Link from "next/link";
import {{ useRouter }} from "next/navigation";
import {{ ArrowLeft }} from "lucide-react";
import {{ create{pascal_entity} }} from "@/actions/{entity_name.lower()}";
import {{ Nav }} from "@/components/nav";
import {{ Button }} from "@/components/ui/button";
import {{ Card, CardHeader, CardTitle, CardContent, CardFooter }} from "@/components/ui/card";
import {{ FormField }} from "@/components/form-field";
import {{ Input, Textarea, Select }} from "@/components/ui/input";
import type {{ ActionResponse }} from "@/types/api";
import type {{ {pascal_entity} }} from "@/types/entities";

interface FormState {{
  success: boolean;
  error?: string;
  errors?: Record<string, string[]>;
}}

const initialState: FormState = {{
  success: false,
}};

async function createAction(
  _prevState: FormState,
  formData: FormData
): Promise<FormState> {{
  const data = Object.fromEntries(formData.entries());
  const result = await create{pascal_entity}(data as any);
  return result;
}}

function SubmitButton() {{
  const {{ pending }} = useFormStatus();
  return (
    <Button type="submit" disabled={{pending}}>
      {{pending ? "Creating..." : "Create"}}
    </Button>
  );
}}

export default function Create{pascal_entity}Page() {{
  const router = useRouter();
  const [state, formAction] = useFormState(createAction, initialState);

  if (state.success) {{
    router.push("/{snake_name}s");
  }}

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="page-container">
        <div className="mb-6">
          <Link
            href="/{snake_name}s"
            className="inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to list
          </Link>
        </div>

        <Card className="max-w-2xl">
          <form action={{formAction}}>
            <CardHeader>
              <CardTitle>{title}</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {{state.error && (
                <div className="rounded-md bg-red-50 p-3 text-sm text-red-600">
                  {{state.error}}
                </div>
              )}}

{form_fields}
            </CardContent>
            <CardFooter className="flex justify-end gap-2">
              <Button variant="secondary" type="button" asChild>
                <Link href="/{snake_name}s">
                  Cancel
                </Link>
              </Button>
              <SubmitButton />
            </CardFooter>
          </form>
        </Card>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / f"{snake_name}s" / "new" / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_edit_page(self, surface: ir.SurfaceSpec, result: GeneratorResult) -> None:
        """Generate edit page."""
        snake_name = surface.name.lower().replace("_edit", "").replace("_update", "")
        entity_name = surface.entity_ref or snake_name
        pascal_entity = self._pascal_case(entity_name)
        title = surface.title or f"Edit {pascal_entity}"

        entity = self._get_entity(entity_name)
        if not entity:
            return

        # Build form fields
        form_fields = self._build_form_fields(entity, surface, is_create=False)

        content = f'''"use client";

// {title} Page
// Generated by DAZZLE Next.js Onebox Stack

import {{ useEffect, useState }} from "react";
import {{ useFormState, useFormStatus }} from "react-dom";
import Link from "next/link";
import {{ useRouter }} from "next/navigation";
import {{ ArrowLeft }} from "lucide-react";
import {{ get{pascal_entity}, update{pascal_entity} }} from "@/actions/{entity_name.lower()}";
import {{ Button }} from "@/components/ui/button";
import {{ Card, CardHeader, CardTitle, CardContent, CardFooter }} from "@/components/ui/card";
import {{ FormField }} from "@/components/form-field";
import {{ Input, Textarea, Select }} from "@/components/ui/input";
import {{ LoadingPage }} from "@/components/loading";
import type {{ {pascal_entity} }} from "@/types/entities";

interface PageProps {{
  params: Promise<{{ id: string }}>;
}}

interface FormState {{
  success: boolean;
  error?: string;
  errors?: Record<string, string[]>;
}}

const initialState: FormState = {{
  success: false,
}};

function SubmitButton() {{
  const {{ pending }} = useFormStatus();
  return (
    <Button type="submit" disabled={{pending}}>
      {{pending ? "Saving..." : "Save Changes"}}
    </Button>
  );
}}

export default function Edit{pascal_entity}Page({{ params }}: PageProps) {{
  const router = useRouter();
  const [item, setItem] = useState<{pascal_entity} | null>(null);
  const [loading, setLoading] = useState(true);
  const [id, setId] = useState<string>("");

  useEffect(() => {{
    params.then(async (p) => {{
      setId(p.id);
      const data = await get{pascal_entity}(p.id);
      setItem(data);
      setLoading(false);
    }});
  }}, [params]);

  const updateAction = async (
    _prevState: FormState,
    formData: FormData
  ): Promise<FormState> => {{
    const data = Object.fromEntries(formData.entries());
    const result = await update{pascal_entity}(id, data as any);
    if (result.success) {{
      router.push(`/{snake_name}s/${{id}}`);
    }}
    return result;
  }};

  const [state, formAction] = useFormState(updateAction, initialState);

  if (loading) {{
    return <LoadingPage />;
  }}

  if (!item) {{
    return (
      <div className="page-container">
        <p>Item not found</p>
      </div>
    );
  }}

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="page-container">
        <div className="mb-6">
          <Link
            href={{`/{snake_name}s/${{id}}`}}
            className="inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to details
          </Link>
        </div>

        <Card className="max-w-2xl">
          <form action={{formAction}}>
            <CardHeader>
              <CardTitle>{title}</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {{state.error && (
                <div className="rounded-md bg-red-50 p-3 text-sm text-red-600">
                  {{state.error}}
                </div>
              )}}

{form_fields.replace('defaultValue={}', 'defaultValue={item.')}
            </CardContent>
            <CardFooter className="flex justify-end gap-2">
              <Button variant="secondary" type="button" asChild>
                <Link href={{`/{snake_name}s/${{id}}`}}>
                  Cancel
                </Link>
              </Button>
              <SubmitButton />
            </CardFooter>
          </form>
        </Card>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / f"{snake_name}s" / "[id]" / "edit" / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _generate_dashboard_page(self, surface: ir.SurfaceSpec, result: GeneratorResult) -> None:
        """Generate dashboard page with regions."""
        snake_name = surface.name.lower()
        title = surface.title or surface.name.replace("_", " ").title()

        content = f'''// {title} Dashboard
// Generated by DAZZLE Next.js Onebox Stack

import {{ getCurrentUser }} from "@/lib/auth";
import {{ Nav }} from "@/components/nav";
import {{ Card, CardHeader, CardTitle, CardContent }} from "@/components/ui/card";

export default async function {self._pascal_case(surface.name)}Page() {{
  const user = await getCurrentUser();

  return (
    <div className="min-h-screen bg-gray-50">
      <Nav user={{user}} />
      <main className="page-container">
        <h1 className="mb-8">{title}</h1>

        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          <Card>
            <CardHeader>
              <CardTitle>Welcome</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-gray-600">
                Dashboard content will be generated from workspace regions.
              </p>
            </CardContent>
          </Card>
        </div>
      </main>
    </div>
  );
}}
'''
        path = self.output_dir / "src" / "app" / snake_name / "page.tsx"
        self._write_file(path, content)
        result.add_file(path)

    def _get_entity(self, name: str) -> ir.EntitySpec | None:
        """Get entity by name."""
        for entity in self.spec.domain.entities:
            if entity.name.lower() == name.lower():
                return entity
        return None

    def _build_table_columns(self, entity: ir.EntitySpec, surface: ir.SurfaceSpec) -> list[dict]:
        """Build column definitions for DataTable."""
        columns = []
        for field in entity.fields:
            if field.is_primary_key and field.type.kind == ir.FieldTypeKind.UUID:
                continue  # Skip UUID primary keys in table

            columns.append({
                "accessor": self._camel_case(field.name),
                "title": field.name.replace("_", " ").title(),
                "sortable": True,
                "field_type": field.type.kind,  # Include type for render logic
            })

        return columns[:6]  # Limit to 6 columns

    def _build_detail_fields(self, entity: ir.EntitySpec, surface: ir.SurfaceSpec) -> str:
        """Build field displays for detail page."""
        lines = []
        for field in entity.fields:
            camel_name = self._camel_case(field.name)
            label = field.name.replace("_", " ").title()

            lines.append(f'''              <div>
                <dt className="text-sm font-medium text-gray-500">{label}</dt>
                <dd className="mt-1 text-sm text-gray-900">{{String(item.{camel_name} ?? "-")}}</dd>
              </div>''')

        return "\n".join(lines)

    def _build_form_fields(self, entity: ir.EntitySpec, surface: ir.SurfaceSpec, is_create: bool) -> str:
        """Build form fields for create/edit page."""
        lines = []
        for field in entity.fields:
            # Skip auto-generated fields
            if field.is_primary_key and field.type.kind == ir.FieldTypeKind.UUID:
                continue
            if ir.FieldModifier.AUTO_ADD in field.modifiers or ir.FieldModifier.AUTO_UPDATE in field.modifiers:
                continue

            camel_name = self._camel_case(field.name)
            label = field.name.replace("_", " ").title()
            required = field.is_required

            # For edit mode, use item.fieldName; for create mode, use empty string
            default_value_expr = "item." + camel_name if not is_create else '""'
            default_checked_expr = "item." + camel_name if not is_create else "false"

            # For date/datetime fields, need to convert to string format
            if field.type.kind == ir.FieldTypeKind.DATE and not is_create:
                default_value_expr = f"item.{camel_name} ? new Date(item.{camel_name}).toISOString().split('T')[0] : ''"
            elif field.type.kind == ir.FieldTypeKind.DATETIME and not is_create:
                default_value_expr = f"item.{camel_name} ? new Date(item.{camel_name}).toISOString().slice(0, 16) : ''"

            # Determine input type
            if field.type.kind == ir.FieldTypeKind.TEXT:
                input_elem = f'''<Textarea
                  id="{camel_name}"
                  name="{camel_name}"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''
            elif field.type.kind == ir.FieldTypeKind.BOOL:
                input_elem = f'''<input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="checkbox"
                  defaultChecked={{{default_checked_expr}}}
                  className="h-4 w-4 rounded border-gray-300"
                />'''
            elif field.type.kind == ir.FieldTypeKind.ENUM and field.type.enum_values:
                options = "\n                    ".join(
                    f'<option value="{v}">{v}</option>'
                    for v in field.type.enum_values
                )
                input_elem = f'''<Select
                  id="{camel_name}"
                  name="{camel_name}"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                >
                  <option value="">Select...</option>
                    {options}
                </Select>'''
            elif field.type.kind == ir.FieldTypeKind.INT:
                input_elem = f'''<Input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="number"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''
            elif field.type.kind == ir.FieldTypeKind.DATE:
                input_elem = f'''<Input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="date"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''
            elif field.type.kind == ir.FieldTypeKind.DATETIME:
                input_elem = f'''<Input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="datetime-local"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''
            elif field.type.kind == ir.FieldTypeKind.EMAIL:
                input_elem = f'''<Input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="email"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''
            else:
                input_elem = f'''<Input
                  id="{camel_name}"
                  name="{camel_name}"
                  type="text"
                  defaultValue={{{default_value_expr}}}
                  error={{!!state.errors?.{camel_name}}}
                />'''

            lines.append(f'''              <FormField
                label="{label}"
                htmlFor="{camel_name}"
                required={{{str(required).lower()}}}
                error={{state.errors?.{camel_name}?.[0]}}
              >
                {input_elem}
              </FormField>''')

        return "\n\n".join(lines)

    def _pascal_case(self, name: str) -> str:
        """Convert to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _camel_case(self, name: str) -> str:
        """Convert to camelCase."""
        pascal = self._pascal_case(name)
        return pascal[0].lower() + pascal[1:] if pascal else ""
