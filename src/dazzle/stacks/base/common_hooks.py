"""
Common hooks that can be reused across backends.

These hooks provide generic functionality useful for multiple backends:
- Environment file generation
- Credential generation
- Setup instructions display
- Dependency validation
"""

import secrets

from .hooks import Hook, HookContext, HookPhase, HookResult


class CreateEnvFileHook(Hook):
    """
    Create .env file with secure defaults.

    Generates environment variables with secure random secrets.
    """

    name = "create_env_file"
    description = "Generate .env file with secure configuration"
    phase = HookPhase.POST_BUILD

    def __init__(self, env_vars: dict[str, str] | None = None):
        """
        Initialize hook.

        Args:
            env_vars: Additional environment variables to include
        """
        self.env_vars = env_vars or {}

    def execute(self, context: HookContext) -> HookResult:
        """Generate .env file."""
        # Generate secure secrets
        session_secret = secrets.token_hex(32)
        app_secret = secrets.token_hex(32)

        # Build env content
        lines = [
            f"# Generated by DAZZLE - {context.backend_name}",
            f"# Application: {context.spec.name}",
            "",
            "# Security",
            f"SECRET_KEY={app_secret}",
            f"SESSION_SECRET={session_secret}",
            "",
            "# Environment",
            "DEBUG=false  # Set to 'true' for development",
            "",
        ]

        # Add custom env vars
        if self.env_vars:
            lines.append("# Custom Configuration")
            for key, value in self.env_vars.items():
                lines.append(f"{key}={value}")
            lines.append("")

        content = "\n".join(lines)

        # Write .env file
        env_file = context.output_dir / context.spec.name / ".env"
        env_file.parent.mkdir(parents=True, exist_ok=True)
        env_file.write_text(content)

        return HookResult(
            success=True,
            message=f".env file created at {env_file}",
            artifacts={
                "env_file": str(env_file),
                "secret_key": app_secret,
                "session_secret": session_secret,
            },
            display_to_user=True,
        )


class DisplaySetupInstructionsHook(Hook):
    """
    Display setup instructions after build.

    Shows user how to run their generated application.
    """

    name = "display_setup_instructions"
    description = "Display setup instructions"
    phase = HookPhase.POST_BUILD

    def __init__(self, instructions: list[str] | None = None):
        """
        Initialize hook.

        Args:
            instructions: List of instruction lines to display
        """
        self.instructions = instructions or []

    def execute(self, context: HookContext) -> HookResult:
        """Display instructions."""
        if not self.instructions:
            return HookResult(
                success=True, message="No setup instructions provided", display_to_user=False
            )

        # Build formatted output
        lines = [
            "",
            "=" * 60,
            "ðŸŽ‰ Build Complete!",
            "=" * 60,
            "",
            f"Application: {context.spec.name}",
            f"Output: {context.output_dir / context.spec.name}",
            "",
            "Setup Instructions:",
            "",
        ]

        for i, instruction in enumerate(self.instructions, 1):
            lines.append(f"  {i}. {instruction}")

        lines.append("")
        lines.append("=" * 60)
        lines.append("")

        message = "\n".join(lines)
        print(message)

        return HookResult(
            success=True,
            message="Instructions displayed",
            display_to_user=False,  # Already printed
        )


class ValidateOutputDirHook(Hook):
    """
    Validate output directory before build.

    Checks that output directory is writable and handles conflicts.
    """

    name = "validate_output_dir"
    description = "Validate output directory is writable"
    phase = HookPhase.PRE_BUILD

    def execute(self, context: HookContext) -> HookResult:
        """Validate output directory."""
        output_dir = context.output_dir

        # Check if parent directory exists and is writable
        if output_dir.exists():
            if not output_dir.is_dir():
                return HookResult(
                    success=False,
                    message=f"Output path exists but is not a directory: {output_dir}",
                    display_to_user=True,
                    stop_on_failure=True,
                )

        # Try to create output directory
        try:
            output_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            return HookResult(
                success=False,
                message=f"No permission to create output directory: {output_dir}",
                display_to_user=True,
                stop_on_failure=True,
            )
        except Exception as e:
            return HookResult(
                success=False,
                message=f"Failed to create output directory: {e}",
                display_to_user=True,
                stop_on_failure=True,
            )

        return HookResult(
            success=True, message=f"Output directory validated: {output_dir}", display_to_user=False
        )


class CreateGitignoreHook(Hook):
    """
    Create .gitignore file for generated project.

    Includes common patterns for the backend type.
    """

    name = "create_gitignore"
    description = "Generate .gitignore file"
    phase = HookPhase.POST_BUILD

    def __init__(self, additional_patterns: list[str] | None = None):
        """
        Initialize hook.

        Args:
            additional_patterns: Additional patterns to include in .gitignore
        """
        self.additional_patterns = additional_patterns or []

    def execute(self, context: HookContext) -> HookResult:
        """Generate .gitignore."""
        # Common patterns
        patterns = [
            "# DAZZLE Generated",
            "",
            "# Environment",
            ".env",
            ".env.local",
            "",
            "# Secrets",
            "*.key",
            "*.pem",
            ".admin_credentials",
            "",
            "# Dependencies",
            "node_modules/",
            "__pycache__/",
            "*.pyc",
            "venv/",
            ".venv/",
            "",
            "# Build",
            "dist/",
            "build/",
            "*.egg-info/",
            "",
            "# IDE",
            ".vscode/",
            ".idea/",
            "*.swp",
            "*.swo",
            "*~",
            "",
            "# OS",
            ".DS_Store",
            "Thumbs.db",
            "",
        ]

        # Add custom patterns
        if self.additional_patterns:
            patterns.append("# Backend-specific")
            patterns.extend(self.additional_patterns)
            patterns.append("")

        content = "\n".join(patterns)

        # Write .gitignore
        gitignore_file = context.output_dir / context.spec.name / ".gitignore"
        gitignore_file.write_text(content)

        return HookResult(
            success=True,
            message=f".gitignore created with {len(patterns)} patterns",
            artifacts={"gitignore_file": str(gitignore_file)},
            display_to_user=False,
        )
