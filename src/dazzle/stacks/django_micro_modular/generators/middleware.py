"""
Middleware generator for Django Micro backend.

Generates Django middleware for UX Semantic Layer features like persona detection.
"""

from pathlib import Path

from ....core import ir
from ...base import Generator, GeneratorResult


class MiddlewareGenerator(Generator):
    """
    Generate Django middleware for UX features.

    Creates:
    - middleware.py - Persona detection and UX context middleware
    """

    def __init__(self, spec: ir.AppSpec, output_dir: Path, app_name: str = "app"):
        """
        Initialize middleware generator.

        Args:
            spec: Application specification
            output_dir: Root output directory
            app_name: Name of the Django app
        """
        super().__init__(spec, output_dir)
        self.app_name = app_name

    def generate(self) -> GeneratorResult:
        """Generate middleware file if personas are defined."""
        result = GeneratorResult()

        # Check if any surfaces have persona variants
        personas = self._collect_personas()
        if not personas:
            return result

        # Generate middleware file
        middleware_code = self._generate_middleware(personas)
        middleware_path = self.output_dir / self.app_name / "middleware.py"
        self._write_file(middleware_path, middleware_code)
        result.add_file(middleware_path)

        # Record that middleware was generated for settings configuration
        result.add_artifact("middleware_classes", [f"{self.app_name}.middleware.PersonaMiddleware"])
        result.add_artifact("personas", list(personas))

        return result

    def _collect_personas(self) -> set[str]:
        """Collect all unique personas from surface UX specs."""
        personas: set[str] = set()

        for surface in self.spec.surfaces:
            if surface.ux and surface.ux.persona_variants:
                for variant in surface.ux.persona_variants:
                    personas.add(variant.persona)

        return personas

    def _generate_middleware(self, personas: set[str]) -> str:
        """Generate persona detection middleware."""
        personas_list = sorted(personas)
        personas_tuple = ", ".join(f'"{p}"' for p in personas_list)

        return f'''"""
Django middleware for UX Semantic Layer persona detection.

Generated by DAZZLE - DO NOT EDIT MANUALLY
"""

from django.conf import settings


# Available personas in this application
AVAILABLE_PERSONAS = ({personas_tuple})


class PersonaMiddleware:
    """
    Middleware that detects and injects user personas into requests.

    Configurable via settings:
    - PERSONA_DETECTOR: Path to custom persona detection function
    - PERSONA_DEFAULT: Default persona for anonymous users (default: None)
    - PERSONA_HEADER: HTTP header for persona override (default: X-Persona)

    The persona detection function should have signature:
        def detect_persona(request) -> str | list[str] | None

    Usage in views:
        def my_view(request):
            personas = request.personas  # list of persona strings
            primary_persona = request.persona  # first persona or None
    """

    def __init__(self, get_response):
        self.get_response = get_response

        # Load configuration from settings
        self.detector_path = getattr(settings, 'PERSONA_DETECTOR', None)
        self.default_persona = getattr(settings, 'PERSONA_DEFAULT', None)
        self.persona_header = getattr(settings, 'PERSONA_HEADER', 'X-Persona')

        # Load custom detector if configured
        self.custom_detector = None
        if self.detector_path:
            self.custom_detector = self._load_detector(self.detector_path)

    def _load_detector(self, path: str):
        """Load custom persona detector function from path."""
        try:
            module_path, func_name = path.rsplit('.', 1)
            import importlib
            module = importlib.import_module(module_path)
            return getattr(module, func_name)
        except (ValueError, ImportError, AttributeError) as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.warning(f"Failed to load persona detector '{{path}}': {{e}}")
            return None

    def __call__(self, request):
        # Detect personas
        personas = self._detect_personas(request)

        # Inject into request
        request.personas = personas
        request.persona = personas[0] if personas else None

        # Process request
        response = self.get_response(request)

        return response

    def _detect_personas(self, request) -> list[str]:
        """
        Detect user personas using configured detection strategy.

        Detection priority:
        1. Header override (for testing/impersonation)
        2. Custom detector function
        3. Default fallback based on user authentication

        Returns:
            List of persona identifiers (may be empty)
        """
        personas = []

        # 1. Check header override (useful for testing)
        header_persona = request.META.get(f'HTTP_{{self.persona_header.upper().replace("-", "_")}}')
        if header_persona:
            # Validate against known personas
            if header_persona in AVAILABLE_PERSONAS:
                personas.append(header_persona)
            return personas

        # 2. Use custom detector if available
        if self.custom_detector:
            result = self.custom_detector(request)
            if result:
                if isinstance(result, str):
                    personas.append(result)
                elif isinstance(result, (list, tuple)):
                    personas.extend(result)
            return personas

        # 3. Default detection based on user
        if hasattr(request, 'user') and request.user.is_authenticated:
            # Check for user groups matching personas
            if hasattr(request.user, 'groups'):
                user_groups = set(g.name.lower() for g in request.user.groups.all())
                for persona in AVAILABLE_PERSONAS:
                    if persona.lower() in user_groups:
                        personas.append(persona)

            # Check for is_staff/is_superuser mappings
            if not personas:
                if getattr(request.user, 'is_superuser', False):
                    # Superusers typically have admin/coordinator role
                    for p in ['admin', 'coordinator', 'manager']:
                        if p in AVAILABLE_PERSONAS:
                            personas.append(p)
                            break
                elif getattr(request.user, 'is_staff', False):
                    # Staff members might be coordinators
                    for p in ['coordinator', 'staff', 'manager']:
                        if p in AVAILABLE_PERSONAS:
                            personas.append(p)
                            break

        # 4. Apply default if no personas detected
        if not personas and self.default_persona:
            if self.default_persona in AVAILABLE_PERSONAS:
                personas.append(self.default_persona)

        return personas


def get_persona_context(request) -> dict:
    """
    Get template context for persona-aware rendering.

    Usage in views:
        def my_view(request):
            context = get_persona_context(request)
            context['my_data'] = ...
            return render(request, 'template.html', context)
    """
    return {{
        'personas': getattr(request, 'personas', []),
        'persona': getattr(request, 'persona', None),
        'available_personas': AVAILABLE_PERSONAS,
    }}


class PersonaContextMiddleware:
    """
    Middleware that adds persona context to template rendering.

    This is a convenience middleware that automatically adds persona
    information to the template context for all requests.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        return self.get_response(request)

    def process_template_response(self, request, response):
        """Add persona context to template responses."""
        if hasattr(response, 'context_data') and response.context_data is not None:
            response.context_data.update(get_persona_context(request))
        return response
'''
