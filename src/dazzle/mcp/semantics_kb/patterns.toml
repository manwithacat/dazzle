# DSL Patterns with Copy-Paste Examples
# Auto-generated from semantics.py

[meta]
pattern_count = 19


[patterns.adapter_result]
category = "Integration (v0.6)"
definition = "Result type for adapter operations using success/failure pattern instead of exceptions for expected errors."
syntax = '''
AdapterResult[T] = Success with data or Failure with error

result = await adapter.get_data(id)
if result.is_success:
    data = result.data  # Access the data
else:
    error = result.error  # Handle the error
'''
example = '''
async def fetch_customer_data(customer_id: str):
    result = await crm_adapter.get_customer(customer_id)

    if result.is_success:
        return result.data

    # Handle specific error types
    if result.error.status_code == 404:
        return None  # Customer not found

    # Re-raise unexpected errors
    raise result.error

# Or use unwrap_or for defaults:
data = result.unwrap_or(default_data)

# Or map the result:
names = result.map(lambda data: data["name"])
'''
related = ["external_adapter", "error_normalization"]
v0_6_changes = "NEW in v0.6"

[patterns.audit_trail]
name = "Audit Trail Pattern"
description = "Track who changed what and when"
example = '''
# Entity with full audit fields
entity Document "Document":
  id: uuid pk
  title: str(200) required
  content: text
  # Audit fields
  created_by: ref User required
  created_at: datetime auto_add
  updated_by: ref User optional
  updated_at: datetime auto_update
  version: int=1

surface document_history "Document History":
  uses entity Document
  mode: view
  section main:
    field title
    field version
  section audit "Audit Trail":
    field created_by.name "Created By"
    field created_at "Created At"
    field updated_by.name "Last Updated By"
    field updated_at "Last Updated At" 
'''

[patterns.business_logic_pattern]
name = "Business Logic Pattern"
description = "Complete entity with state machine, invariants, computed fields, and access rules"
v0_7_feature = true
components = ["State machine with guarded transitions", "Computed fields for derived values", "Invariants for cross-field validation", "Access rules for row-level security"]
example = '''
# Complete v0.7.0 Entity with Business Logic
entity Ticket "Support Ticket":
  id: uuid pk
  ticket_number: str(20) unique
  title: str(200) required
  description: text required
  status: enum[open,in_progress,resolved,closed]=open
  priority: enum[low,medium,high,critical]=medium
  created_by: ref User required
  assigned_to: ref User
  resolution: text
  created_at: datetime auto_add
  updated_at: datetime auto_update

  # Computed field: days since opened
  days_open: computed days_since(created_at)

  # State machine: ticket lifecycle
  transitions:
    open -> in_progress: requires assigned_to
    in_progress -> resolved: requires resolution
    in_progress -> open
    resolved -> closed
    resolved -> in_progress
    closed -> open: role(manager)

  # Invariants: data integrity rules
  # IMPORTANT: Use single = for equality (not ==)
  invariant: status != resolved or resolution != null
  invariant: status != closed or resolution != null
  invariant: priority != critical or assigned_to != null

  # Access rules: visibility and permissions
  access:
    read: created_by = current_user or role(agent) or role(manager)
    write: role(agent) or role(manager)

  # Indexes for performance
  index status, priority
  index assigned_to
'''
use_cases = ["Workflow systems (tickets, orders, approvals)", "Document lifecycle management", "Multi-role applications with row-level security", "Data integrity enforcement at the model level"]
related = ["state_machine", "invariant", "computed_field", "access_rules"]

[patterns.crud]
name = "CRUD Pattern"
description = "Complete create-read-update-delete interface for an entity"
surfaces = ["{entity}_list (list mode)", "{entity}_detail (view mode)", "{entity}_create (create mode)", "{entity}_edit (edit mode)"]
example = '''
# Complete CRUD for Task entity
entity Task "Task":
  id: uuid pk
  title: str(200) required
  description: text optional
  status: enum[todo,in_progress,done]=todo
  created_at: datetime auto_add

surface task_list "Tasks":
  uses entity Task
  mode: list
  section main:
    field title
    field status
  ux:
    purpose: "View and manage all tasks"
    sort: created_at desc
    filter: status

surface task_detail "Task Details":
  uses entity Task
  mode: view
  section main:
    field title
    field description
    field status
    field created_at

surface task_create "New Task":
  uses entity Task
  mode: create
  section main:
    field title
    field description

surface task_edit "Edit Task":
  uses entity Task
  mode: edit
  section main:
    field title
    field description
    field status
'''

[patterns.dashboard]
name = "Dashboard Pattern"
description = "Workspace aggregating multiple data views with metrics"
components = ["Metrics/KPIs", "Recent activity", "Alerts/attention items", "Quick actions"]
v0_2_feature = true
example = '''
# Team dashboard with metrics and activity
workspace team_dashboard "Team Dashboard":
  purpose: "Real-time team overview and key metrics"

  # Urgent items needing attention
  urgent_items:
    source: Task
    filter: priority = high and status != done
    sort: due_date asc
    limit: 5
    action: task_edit
    empty: "All caught up!"

  # Recent completions
  recent_done:
    source: Task
    filter: status = done
    sort: completed_at desc
    limit: 10
    display: timeline

  # Key performance metrics
  metrics:
    aggregate:
      total: count(Task)
      completed: count(Task where status = done)
      in_progress: count(Task where status = in_progress)
      completion_rate: round(count(Task where status = done) * 100 / count(Task), 1)
'''

[patterns.domain_service_pattern]
name = "Domain Service Pattern"
description = "Custom business logic with DSL declaration and stub implementation"
v0_5_feature = true
components = ["DSL service declaration with kind, input, output", "Guarantees documenting contracts", "Python/TypeScript stub implementation"]
example = '''
# DSL declaration in app.dsl
entity Invoice "Invoice":
  id: uuid pk
  total: decimal(10,2) required
  country: str(2) required
  vat_amount: decimal(10,2) optional

service calculate_vat "Calculate VAT for Invoice":
  kind: domain_logic
  input:
    invoice_id: uuid required
    country_code: str(2)
  output:
    vat_amount: decimal(10,2)
    breakdown: json
  guarantees:
    - "Must not mutate the invoice record"
    - "Must raise domain error if config incomplete"
  stub: python

# Generate stub file:
# $ dazzle stubs generate --service calculate_vat

# Implement in stubs/calculate_vat.py:
def calculate_vat(invoice_id: str, country_code: str | None = None) -> CalculateVatResult:
    invoice = db.get_invoice(invoice_id)
    country = country_code or invoice.country

    # VAT rates by country
    rates = {"GB": 0.20, "DE": 0.19, "FR": 0.20, "US": 0.0}
    rate = rates.get(country, 0.0)

    return {
        "vat_amount": float(invoice.total) * rate,
        "breakdown": {
            "rate": rate,
            "country": country,
            "net": float(invoice.total),
            "gross": float(invoice.total) * (1 + rate)
        }
    }
'''
use_cases = ["Complex calculations (pricing, tax, discounts)", "External API integration (payment, email)", "Multi-step workflows (approval processes)", "Cross-entity validation rules"]

[patterns.ejection_pattern]
name = "Ejection Pattern"
description = "Generate standalone application code from DAZZLE specification for custom deployment"
v0_7_2_feature = true
components = ["Ejection configuration in dazzle.toml", "Backend adapter (FastAPI with SQLAlchemy)", "Frontend adapter (React with TanStack Query)", "Testing adapter (Schemathesis, Pytest)", "CI adapter (GitHub Actions, GitLab CI)", "OpenAPI specification generation"]
example = '''
# Step 1: Add ejection configuration to dazzle.toml
[ejection]
enabled = true

[ejection.backend]
framework = "fastapi"
models = "sqlalchemy"
async_handlers = true

[ejection.frontend]
framework = "react"
api_client = "tanstack_query"

[ejection.testing]
contract = "schemathesis"
unit = "pytest"

[ejection.ci]
template = "github_actions"

[ejection.output]
directory = "generated"

# Step 2: Preview what will be generated
dazzle eject run --dry-run

# Step 3: Generate the code
dazzle eject run

# Step 4: Run the generated application
cd generated
docker compose -f docker-compose.dev.yml up

# Step 5: Run the generated tests
cd generated
pytest tests/

# Optional: Generate OpenAPI spec
dazzle eject openapi -o openapi.yaml

# Optional: Check ejection status
dazzle eject status

# Generated file structure:
generated/
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docker-compose.dev.yml
â”œâ”€â”€ Makefile
â”œâ”€â”€ .gitignore
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ {entity}.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â””â”€â”€ {entity}.py
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â””â”€â”€ {entity}.py
â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â””â”€â”€ {entity}_guards.py
â”‚   â”œâ”€â”€ validators/
â”‚   â”‚   â””â”€â”€ {entity}_validators.py
â”‚   â””â”€â”€ access/
â”‚       â””â”€â”€ {entity}_access.py
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ types/
â”‚       â”œâ”€â”€ schemas/
â”‚       â”œâ”€â”€ hooks/
â”‚       â””â”€â”€ components/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ contract/
â”‚   â””â”€â”€ unit/
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â”œâ”€â”€ ci.yml
        â”œâ”€â”€ contract.yml
        â””â”€â”€ deploy.yml
'''
use_cases = ["Deploy to platforms not supporting DNR runtime", "Need code review and audit for compliance", "Performance optimization with precompiled code", "Custom infrastructure requirements", "Migration away from DAZZLE runtime"]
related = ["ejection", "ejection_config", "ejection_adapter", "openapi_generation"]

[patterns.error_category]
category = "Integration (v0.6)"
definition = "High-level error categories for routing and handling decisions in the GraphQL layer."
syntax = '''
ErrorCategory.AUTHENTICATION  # Redirect to login
ErrorCategory.AUTHORIZATION   # Show forbidden message
ErrorCategory.VALIDATION      # Show field-level errors
ErrorCategory.RATE_LIMIT      # Implement backoff
ErrorCategory.TIMEOUT         # Retry or show timeout
ErrorCategory.NOT_FOUND       # Show 404 message
ErrorCategory.EXTERNAL_SERVICE # Show service unavailable
ErrorCategory.INTERNAL        # Log and show generic error
'''
example = '''
# Use categories to route error handling:
def handle_adapter_error(normalized: NormalizedError):
    match normalized.category:
        case ErrorCategory.AUTHENTICATION:
            return redirect_to_login()
        case ErrorCategory.RATE_LIMIT:
            return show_retry_message(normalized.retry_after)
        case ErrorCategory.VALIDATION:
            return show_field_errors(normalized.field_errors)
        case _:
            return show_generic_error(normalized.user_message)
'''
related = ["error_normalization", "error_severity"]
v0_6_changes = "NEW in v0.6"

[patterns.error_normalization]
category = "Integration (v0.6)"
definition = "System for converting diverse external API errors into a consistent format for GraphQL responses."
syntax = '''
from dazzle_dnr_back.graphql.adapters import (
    normalize_error,
    NormalizedError,
    ErrorCategory,
    ErrorSeverity,
)

normalized = normalize_error(error, service_name="hmrc")
'''
example = '''
from dazzle_dnr_back.graphql.adapters import (
    normalize_error,
    ErrorCategory,
    ErrorSeverity,
)

try:
    result = await hmrc_adapter.get_vat_obligations(vrn)
except AdapterError as e:
    normalized = normalize_error(e, request_id="req-123")

    # Access normalized error properties
    print(normalized.code)           # "HMRC_RATE_LIMIT_EXCEEDED"
    print(normalized.category)       # ErrorCategory.RATE_LIMIT
    print(normalized.severity)       # ErrorSeverity.WARNING
    print(normalized.user_message)   # "Too many requests. Please try again in 30 seconds."
    print(normalized.retry_after)    # 30.0

    # Convert to GraphQL error extensions
    extensions = normalized.to_graphql_extensions()
    raise GraphQLError(normalized.user_message, extensions=extensions)
'''
related = ["external_adapter", "adapter_result", "error_category"]
v0_6_changes = "NEW in v0.6"

[patterns.error_severity]
category = "Integration (v0.6)"
definition = "Error severity levels for logging and alerting decisions."
syntax = '''
ErrorSeverity.INFO      # Expected errors (validation, not found)
ErrorSeverity.WARNING   # Recoverable errors (rate limits, timeouts)
ErrorSeverity.ERROR     # Unexpected errors needing attention
ErrorSeverity.CRITICAL  # System errors requiring immediate action
'''
example = '''
# Log based on severity:
def log_error(normalized: NormalizedError):
    log_data = normalized.to_log_dict()

    match normalized.severity:
        case ErrorSeverity.INFO:
            logger.info("Expected error", extra=log_data)
        case ErrorSeverity.WARNING:
            logger.warning("Recoverable error", extra=log_data)
        case ErrorSeverity.ERROR:
            logger.error("Unexpected error", extra=log_data)
        case ErrorSeverity.CRITICAL:
            logger.critical("System error", extra=log_data)
            alert_on_call_team(normalized)
'''
related = ["error_normalization", "error_category"]
v0_6_changes = "NEW in v0.6"

[patterns.external_adapter]
category = "Integration (v0.6)"
definition = "Abstract base class for integrating with external APIs (HMRC, banks, payment providers, etc.) with built-in retry logic, rate limiting, and error normalization."
syntax = '''
from dazzle_dnr_back.graphql.adapters import (
    BaseExternalAdapter,
    AdapterConfig,
    AdapterResult,
)

class MyServiceAdapter(BaseExternalAdapter[AdapterConfig]):
    async def get_data(self, id: str) -> AdapterResult[dict]:
        return await self._get(f"/api/data/{id}")
'''
example = '''
from dazzle_dnr_back.graphql.adapters import (
    BaseExternalAdapter,
    AdapterConfig,
    RetryConfig,
    RateLimitConfig,
    AdapterResult,
)

class HMRCAdapter(BaseExternalAdapter[AdapterConfig]):
    """Adapter for HMRC VAT API."""

    def __init__(self, bearer_token: str):
        config = AdapterConfig(
            base_url="https://api.service.hmrc.gov.uk",
            timeout=30.0,
            headers={"Authorization": f"Bearer {bearer_token}"},
            retry=RetryConfig(max_retries=3, base_delay=1.0),
            rate_limit=RateLimitConfig(requests_per_second=4),
        )
        super().__init__(config)

    async def get_vat_obligations(
        self, vrn: str, from_date: str, to_date: str
    ) -> AdapterResult[list[dict]]:
        """Fetch VAT obligations for a business."""
        return await self._get(
            f"/organisations/vat/{vrn}/obligations",
            params={"from": from_date, "to": to_date, "status": "O"},
        )
'''
related = ["error_normalization", "adapter_result", "graphql_bff_pattern"]
v0_6_changes = "NEW in v0.6"

[patterns.graphql_bff_pattern]
name = "GraphQL BFF Pattern"
description = "Backend-for-Frontend using GraphQL as the API layer between UI and backend services"
v0_6_feature = true
components = ["GraphQL schema generated from BackendSpec entities", "Auto-generated resolvers for CRUD operations", "External API adapters for third-party integrations", "Unified error normalization"]
example = '''
# GraphQL schema is auto-generated from your entities:
# entity Task â†’ GraphQL type Task with Query/Mutation

# Inspect the generated schema:
# $ dazzle dnr inspect --schema

# Mount GraphQL endpoint in your app:
from dazzle_dnr_back.graphql import mount_graphql
mount_graphql(app, backend_spec)

# Query example:
query {
  tasks(status: "todo") {
    id
    title
    status
  }
}

# Mutation example:
mutation {
  createTask(input: {title: "New task"}) {
    id
    title
  }
}
'''
use_cases = ["Mobile apps needing flexible data fetching", "Complex UIs with nested data requirements", "Multi-client applications (web, mobile, desktop)", "APIs aggregating multiple external services"]

[patterns.graphql_schema_inspection]
category = "CLI (v0.6)"
definition = "CLI command to inspect the auto-generated GraphQL schema from BackendSpec."
syntax = '''
# Display GraphQL SDL
dazzle dnr inspect --schema

# Get schema info as JSON
dazzle dnr inspect --schema --format json
'''
example = '''
$ dazzle dnr inspect --schema
ðŸ“Š GraphQL Schema

type Query {
  task(id: ID!): Task
  tasks(status: String, limit: Int): [Task!]!
}

type Mutation {
  createTask(input: TaskInput!): Task!
  updateTask(id: ID!, input: TaskInput!): Task!
  deleteTask(id: ID!): Boolean!
}

type Task {
  id: ID!
  title: String!
  status: String!
  createdAt: DateTime!
}

input TaskInput {
  title: String!
  status: String
}
'''
related = ["graphql_bff_pattern", "external_adapter"]
v0_6_changes = "NEW in v0.6"

[patterns.kanban_board]
name = "Kanban Board Pattern"
description = "Status-based workflow visualization"
example = '''
# Kanban-style task board
entity Task "Task":
  id: uuid pk
  title: str(200) required
  status: enum[backlog,todo,in_progress,review,done]=backlog
  priority: enum[low,medium,high]=medium
  assigned_to: ref User optional

workspace kanban "Task Board":
  purpose: "Visual workflow management"

  backlog:
    source: Task
    filter: status = backlog
    sort: priority desc
    display: grid
    action: task_edit

  in_progress:
    source: Task
    filter: status = in_progress
    sort: priority desc
    display: grid

  review:
    source: Task
    filter: status = review
    sort: priority desc
    display: grid

  done:
    source: Task
    filter: status = done
    sort: completed_at desc
    limit: 20
    display: grid
'''

[patterns.llm_cognition_pattern]
name = "LLM Cognition Pattern"
description = "Entity design optimized for LLM understanding with intent, semantic tags, archetypes, and example data"
v0_7_1_feature = true
components = ["Intent declaration explaining entity purpose", "Domain and patterns tags for classification", "Archetypes for shared field patterns", "Example records for data understanding", "Invariant messages for clear validation errors", "Relationship semantics (has_many, embeds, etc)"]
example = '''
# v0.7.1 LLM-Optimized Entity Design

# First, define reusable archetypes
archetype Timestamped:
  created_at: datetime auto_add
  updated_at: datetime auto_update

archetype Auditable:
  created_by: ref User
  updated_by: ref User

# Main entity with full LLM cognition features
entity Invoice "Invoice":
  intent: "Represent a finalized billing request from vendor to customer"
  domain: billing
  patterns: lifecycle, line_items, audit
  extends: Timestamped, Auditable

  id: uuid pk
  invoice_number: str(50) unique required
  status: enum[draft,sent,paid,overdue,cancelled] = draft
  customer: ref Customer required
  items: has_many InvoiceItem cascade
  subtotal: decimal(10,2) required
  tax_amount: decimal(10,2)
  total: decimal(10,2) required
  due_date: date required
  paid_at: datetime

  # Computed fields
  days_until_due: computed days_since(due_date)
  is_overdue: computed due_date < today and status != paid

  # State machine
  transitions:
    draft -> sent: requires customer
    sent -> paid: requires paid_at
    sent -> overdue: auto after 30 days
    sent -> cancelled: role(admin)
    overdue -> paid: requires paid_at
    * -> cancelled: role(admin)

  # Invariants with messages
  invariant: total = subtotal + tax_amount
    message: "Total must equal subtotal plus tax"
    code: INVOICE_TOTAL_MISMATCH

  invariant: status != paid or paid_at != null
    message: "Paid invoices must have a payment date"
    code: INVOICE_MISSING_PAYMENT_DATE

  # Access rules
  access:
    read: role(accountant) or role(admin) or customer = current_user.company
    write: role(accountant) or role(admin)

  # Example data
  examples:
    {invoice_number: "INV-2024-001", status: draft, subtotal: 1000.00, tax_amount: 200.00, total: 1200.00}
    {invoice_number: "INV-2024-002", status: sent, subtotal: 500.00, tax_amount: 100.00, total: 600.00}
    {invoice_number: "INV-2024-003", status: paid, subtotal: 750.00, tax_amount: 150.00, total: 900.00}

entity InvoiceItem "Invoice Line Item":
  intent: "Single line item on an invoice with quantity and pricing"
  domain: billing
  patterns: line_items
  extends: Timestamped

  id: uuid pk
  invoice: belongs_to Invoice
  description: str(500) required
  quantity: int required
  unit_price: decimal(10,2) required
  line_total: computed quantity * unit_price

  invariant: quantity > 0
    message: "Quantity must be positive"
    code: ITEM_INVALID_QUANTITY

  examples:
    {description: "Consulting hours", quantity: 10, unit_price: 150.00}
    {description: "Software license", quantity: 5, unit_price: 99.00}
'''
use_cases = ["LLM-assisted code generation from DSL", "Semantic understanding of domain models", "Automatic documentation generation", "Consistent cross-entity patterns", "Better validation error messages"]
related = ["intent", "archetype", "domain_patterns", "examples", "invariant_message", "relationships"]

[patterns.master_detail]
name = "Master-Detail Pattern"
description = "Parent-child relationship with nested views"
v0_2_feature = false
example = '''
# Project with nested tasks
entity Project "Project":
  id: uuid pk
  name: str(200) required
  status: enum[active,completed,archived]=active

entity Task "Task":
  id: uuid pk
  title: str(200) required
  project: ref Project required
  status: enum[todo,done]=todo

surface project_list "Projects":
  uses entity Project
  mode: list
  section main:
    field name
    field status

surface project_detail "Project":
  uses entity Project
  mode: view
  section info:
    field name
    field status
  section tasks "Tasks":
    uses entity Task
    filter: project = this
    field title
    field status
'''

[patterns.notifications]
name = "Notifications Pattern"
description = "Alert users to important events"
v0_2_feature = true
example = '''
# Surface with attention signals
surface order_list "Orders":
  uses entity Order
  mode: list

  section main:
    field order_number
    field customer.name
    field status
    field total

  ux:
    purpose: "Process and fulfill orders"

    # Payment failed - critical
    attention critical:
      when: payment_status = failed
      message: "Payment failed!"
      action: order_retry_payment

    # Shipping delayed
    attention warning:
      when: days_since(shipped_at) > 5 and status = shipped
      message: "Delayed shipment"

    # New order
    attention notice:
      when: status = new and created_at > today
      message: "New order today" 
'''

[patterns.role_based_access]
name = "Role-Based Access Pattern"
description = "Persona variants controlling scope and capabilities"
personas = ["Admin: full access, all records", "Manager: department/team scope", "Member: own records only"]
v0_2_feature = true
example = '''
# Role-based access with personas
surface ticket_list "Support Tickets":
  uses entity Ticket
  mode: list

  section main:
    field subject
    field status
    field assigned_to.name

  ux:
    purpose: "Manage support tickets by role"

    # Admins see everything, can reassign
    for admin:
      scope: all
      action_primary: ticket_assign
      show_aggregate: total, open, resolved_today

    # Agents see assigned + unassigned
    for agent:
      scope: assigned_to = current_user or assigned_to = null
      action_primary: ticket_respond

    # Customers see only their tickets
    for customer:
      scope: created_by = current_user
      hide: internal_notes, assigned_to
      read_only: true
'''

[patterns.search_filter]
name = "Search & Filter Pattern"
description = "Full-text search with faceted filtering"
v0_2_feature = true
example = '''
# Searchable product catalog
entity Product "Product":
  id: uuid pk
  name: str(200) required
  description: text
  category: enum[electronics,clothing,home,other]
  price: decimal(10,2)
  in_stock: bool=true

surface product_catalog "Products":
  uses entity Product
  mode: list

  section main:
    field name
    field category
    field price
    field in_stock

  ux:
    purpose: "Browse and find products"
    search: name, description
    filter: category, in_stock
    sort: name asc
    empty: "No products match your search" 
'''
