"""
Testing adapters for ejection.

Generates test code for ejected applications:
- Schemathesis for contract testing
- Pytest for unit tests
- State machine and invariant tests
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from dazzle.eject.generator import GeneratorResult

from .base import AdapterRegistry, TestingAdapter

if TYPE_CHECKING:
    from dazzle.core.ir import EntitySpec


class SchemathesisAdapter(TestingAdapter):
    """
    Generates Schemathesis contract tests.

    Schemathesis validates the API against its OpenAPI schema,
    ensuring the implementation matches the specification.
    """

    def generate(self) -> GeneratorResult:
        """Generate Schemathesis test suite."""
        result = GeneratorResult()

        result.merge(self._generate_conftest())
        result.merge(self._generate_contract_tests())

        return result

    def _generate_conftest(self) -> GeneratorResult:
        """Generate pytest conftest for Schemathesis."""
        result = GeneratorResult()

        content = '''"""
Pytest configuration for Schemathesis contract tests.
"""

import pytest
import schemathesis
from fastapi.testclient import TestClient

from app.main import app


@pytest.fixture(scope="session")
def test_client():
    """Create test client for the application."""
    return TestClient(app)


@pytest.fixture(scope="session")
def openapi_schema(test_client):
    """Fetch OpenAPI schema from running application."""
    response = test_client.get("/openapi.json")
    return response.json()


# Load schema for Schemathesis
schema = schemathesis.from_asgi("/openapi.json", app)
'''

        result.add_file(
            self.output_dir / "tests" / "contract" / "conftest.py",
            content,
        )
        return result

    def _generate_contract_tests(self) -> GeneratorResult:
        """Generate contract test file."""
        result = GeneratorResult()

        test_cases = []
        for entity in self.spec.entities:
            entity_lower = entity.name.lower()
            test_cases.append(f'''
@schema.parametrize()
def test_{entity_lower}_api(case):
    """
    Contract test for {entity.name} API endpoints.

    Schemathesis generates test cases from the OpenAPI schema
    and validates responses match the specification.
    """
    response = case.call_asgi(app=app)
    case.validate_response(response)
''')

        content = f'''"""
Schemathesis contract tests.

These tests validate that the API implementation matches
the OpenAPI specification. Schemathesis generates test cases
automatically from the schema.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import schemathesis
from app.main import app

# Load the schema from the application
schema = schemathesis.from_asgi("/openapi.json", app)


@schema.parametrize()
def test_api_contract(case):
    """
    Generic contract test for all API endpoints.

    Validates:
    - Response status codes match schema
    - Response bodies match schema
    - Required fields are present
    - Data types are correct
    """
    response = case.call_asgi(app=app)
    case.validate_response(response)


# Entity-specific contract tests
{"".join(test_cases)}

# Stateful testing for state machines
@schema.parametrize(endpoint="/api/.*")
@schemathesis.settings(max_examples=100)
def test_api_stateful(case):
    """
    Stateful contract testing.

    Tests sequences of API calls to validate
    state machine transitions and business logic.
    """
    response = case.call_asgi(app=app)
    case.validate_response(response)
'''

        result.add_file(
            self.output_dir / "tests" / "contract" / "test_contract.py",
            content,
        )
        return result


class PytestAdapter(TestingAdapter):
    """
    Generates pytest unit tests.

    Creates test stubs and fixtures for:
    - Entity CRUD operations
    - State machine transitions
    - Invariant validators
    - Access control policies
    """

    def generate(self) -> GeneratorResult:
        """Generate pytest test suite."""
        result = GeneratorResult()

        result.merge(self._generate_conftest())
        result.merge(self._generate_entity_tests())
        result.merge(self._generate_guard_tests())
        result.merge(self._generate_validator_tests())
        result.merge(self._generate_access_tests())

        return result

    def _generate_conftest(self) -> GeneratorResult:
        """Generate pytest conftest with fixtures."""
        result = GeneratorResult()

        entity_fixtures = []
        for entity in self.spec.entities:
            entity_lower = entity.name.lower()
            entity_fixtures.append(f'''
@pytest.fixture
def {entity_lower}_data() -> dict:
    """Sample data for {entity.name} entity."""
    return {{
        # TODO: Add sample data for {entity.name}
    }}


@pytest.fixture
def {entity_lower}_instance(db_session, {entity_lower}_data) -> {entity.name}:
    """Create a {entity.name} instance for testing."""
    from app.models import {entity.name}
    instance = {entity.name}(**{entity_lower}_data)
    db_session.add(instance)
    db_session.commit()
    db_session.refresh(instance)
    return instance
''')

        content = f'''"""
Pytest configuration and fixtures.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient

from app.main import app
from app.models import Base


@pytest.fixture(scope="session")
def engine():
    """Create test database engine."""
    return create_engine(
        "sqlite:///:memory:",
        connect_args={{"check_same_thread": False}},
    )


@pytest.fixture(scope="session")
def tables(engine):
    """Create all database tables."""
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)


@pytest.fixture
def db_session(engine, tables):
    """Create a new database session for each test."""
    Session = sessionmaker(bind=engine)
    session = Session()
    yield session
    session.rollback()
    session.close()


@pytest.fixture
def client(db_session):
    """Create test client with database session."""
    def get_db_override():
        return db_session

    app.dependency_overrides[get_db] = get_db_override
    yield TestClient(app)
    app.dependency_overrides.clear()


# Entity fixtures
{"".join(entity_fixtures)}
'''

        result.add_file(
            self.output_dir / "tests" / "unit" / "conftest.py",
            content,
        )
        return result

    def _generate_entity_tests(self) -> GeneratorResult:
        """Generate CRUD tests for each entity."""
        result = GeneratorResult()

        for entity in self.spec.entities:
            content = self._generate_entity_test_file(entity)
            result.add_file(
                self.output_dir / "tests" / "unit" / f"test_{entity.name.lower()}.py",
                content,
            )

        return result

    def _generate_entity_test_file(self, entity: EntitySpec) -> str:
        """Generate test file for a single entity."""
        entity_lower = entity.name.lower()

        return f'''"""
Unit tests for {entity.name} entity.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import pytest
from fastapi import status


class Test{entity.name}CRUD:
    """Test CRUD operations for {entity.name}."""

    def test_create_{entity_lower}(self, client, {entity_lower}_data):
        """Test creating a new {entity.name}."""
        response = client.post("/api/{entity_lower}s", json={entity_lower}_data)
        assert response.status_code == status.HTTP_201_CREATED
        data = response.json()
        assert "id" in data

    def test_get_{entity_lower}(self, client, {entity_lower}_instance):
        """Test retrieving a {entity.name} by ID."""
        response = client.get(f"/api/{entity_lower}s/{{{entity_lower}_instance.id}}")
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["id"] == str({entity_lower}_instance.id)

    def test_list_{entity_lower}s(self, client, {entity_lower}_instance):
        """Test listing all {entity.name}s."""
        response = client.get("/api/{entity_lower}s")
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert isinstance(data, list)
        assert len(data) >= 1

    def test_update_{entity_lower}(self, client, {entity_lower}_instance):
        """Test updating a {entity.name}."""
        update_data = {{"id": str({entity_lower}_instance.id)}}
        response = client.put(
            f"/api/{entity_lower}s/{{{entity_lower}_instance.id}}",
            json=update_data,
        )
        assert response.status_code == status.HTTP_200_OK

    def test_delete_{entity_lower}(self, client, {entity_lower}_instance):
        """Test deleting a {entity.name}."""
        response = client.delete(f"/api/{entity_lower}s/{{{entity_lower}_instance.id}}")
        assert response.status_code == status.HTTP_204_NO_CONTENT

        # Verify deletion
        response = client.get(f"/api/{entity_lower}s/{{{entity_lower}_instance.id}}")
        assert response.status_code == status.HTTP_404_NOT_FOUND

    def test_get_{entity_lower}_not_found(self, client):
        """Test getting non-existent {entity.name}."""
        response = client.get("/api/{entity_lower}s/00000000-0000-0000-0000-000000000000")
        assert response.status_code == status.HTTP_404_NOT_FOUND


class Test{entity.name}Validation:
    """Test validation for {entity.name}."""

    def test_create_{entity_lower}_invalid_data(self, client):
        """Test creating {entity.name} with invalid data."""
        response = client.post("/api/{entity_lower}s", json={{}})
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
'''

    def _generate_guard_tests(self) -> GeneratorResult:
        """Generate tests for state machine guards."""
        result = GeneratorResult()

        # Find entities with state machines
        entities_with_states = [
            e for e in self.spec.entities if any(f.field_type == "state" for f in e.fields)
        ]

        if not entities_with_states:
            return result

        test_cases = []
        for entity in entities_with_states:
            entity_lower = entity.name.lower()
            state_field = next(
                (f for f in entity.fields if f.field_type == "state"),
                None,
            )
            if state_field and state_field.transitions:
                for transition in state_field.transitions:
                    from_state = transition.from_state
                    to_state = transition.to_state
                    test_cases.append(f'''
    def test_{entity_lower}_{from_state}_to_{to_state}(
        self, {entity_lower}_instance, db_session
    ):
        """Test {entity.name} transition from {from_state} to {to_state}."""
        from app.guards import {entity.name}Guards

        # Set initial state
        {entity_lower}_instance.status = "{from_state}"
        db_session.commit()

        # Check if transition is allowed
        guards = {entity.name}Guards()
        can_transition = guards.can_{from_state}_to_{to_state}(
            {entity_lower}_instance,
            db_session,
        )
        assert can_transition is True
''')

        test_body = (
            "".join(test_cases)
            if test_cases
            else '''
    def test_no_guards(self):
        """Placeholder - no state machines defined."""
        pass
'''
        )
        content = f'''"""
Tests for state machine guards.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import pytest


class TestStateGuards:
    """Test state machine transition guards."""
{test_body}
'''

        result.add_file(
            self.output_dir / "tests" / "unit" / "test_guards.py",
            content,
        )
        return result

    def _generate_validator_tests(self) -> GeneratorResult:
        """Generate tests for invariant validators."""
        result = GeneratorResult()

        # Find entities with invariants
        entities_with_invariants = [e for e in self.spec.entities if e.invariants]

        test_cases = []
        for entity in entities_with_invariants:
            entity_lower = entity.name.lower()
            for invariant in entity.invariants:
                test_name = invariant.name or f"{entity_lower}_invariant"
                test_cases.append(f'''
    def test_{test_name}(self, {entity_lower}_data):
        """Test invariant: {invariant.condition}"""
        from app.validators import {entity.name}Validator

        validator = {entity.name}Validator()
        # Valid case
        errors = validator.validate({entity_lower}_data)
        assert len(errors) == 0

    def test_{test_name}_violation(self, {entity_lower}_data):
        """Test invariant violation: {invariant.condition}"""
        from app.validators import {entity.name}Validator

        validator = {entity.name}Validator()
        # TODO: Modify data to violate invariant
        invalid_data = {{**{entity_lower}_data}}
        errors = validator.validate(invalid_data)
        # Uncomment when implementing violation test
        # assert len(errors) > 0
        # assert errors[0].code == "{invariant.code or "INVARIANT_VIOLATION"}"
''')

        test_body = (
            "".join(test_cases)
            if test_cases
            else '''
    def test_no_invariants(self):
        """Placeholder - no invariants defined."""
        pass
'''
        )
        content = f'''"""
Tests for invariant validators.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import pytest


class TestInvariantValidators:
    """Test entity invariant validators."""
{test_body}
'''

        result.add_file(
            self.output_dir / "tests" / "unit" / "test_validators.py",
            content,
        )
        return result

    def _generate_access_tests(self) -> GeneratorResult:
        """Generate tests for access control policies."""
        result = GeneratorResult()

        # Find entities with access rules
        entities_with_access = [e for e in self.spec.entities if e.access_rules]

        test_cases = []
        for entity in entities_with_access:
            entity_lower = entity.name.lower()
            for rule in entity.access_rules:
                test_cases.append(f'''
    def test_{entity_lower}_{rule.operation}_access(self):
        """Test {rule.operation} access for {entity.name}."""
        from app.access import {entity.name}AccessPolicy

        policy = {entity.name}AccessPolicy()
        context = RequestContext(
            user_id="test-user",
            roles=["user"],
        )
        # Test with valid context
        can_access = policy.can_{rule.operation}(context)
        # TODO: Assert based on expected access rules
''')

        test_body = (
            "".join(test_cases)
            if test_cases
            else '''
    def test_no_access_rules(self):
        """Placeholder - no access rules defined."""
        pass
'''
        )
        content = f'''"""
Tests for access control policies.

Generated by DAZZLE Ejection Toolchain v0.7.2
"""

import pytest
from dataclasses import dataclass


@dataclass
class RequestContext:
    """Mock request context for testing."""
    user_id: str
    roles: list[str]


class TestAccessPolicies:
    """Test entity access control policies."""
{test_body}
'''

        result.add_file(
            self.output_dir / "tests" / "unit" / "test_access.py",
            content,
        )
        return result


# Register adapters
AdapterRegistry.register_testing("schemathesis", SchemathesisAdapter)
AdapterRegistry.register_testing("pytest", PytestAdapter)
