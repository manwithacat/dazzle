"""
JavaScript generator for DNR-UI runtime.

Generates pure JavaScript code from UISpec for browser execution.
No React, no frameworks - just vanilla JS with a minimal runtime.

NOTE: The JavaScript runtime has been modularized into separate files in
static/js/. This module now loads from those files via js_loader.py.
The RUNTIME_JS variable is kept for backward compatibility.
"""

from __future__ import annotations

from pathlib import Path

from dazzle_dnr_ui.specs import (
    UISpec,
)

# =============================================================================
# Runtime Loading
# =============================================================================


def _load_runtime_js() -> str:
    """
    Load the runtime JavaScript from modular files.

    Falls back to the inline RUNTIME_JS if the loader is not available.
    """
    try:
        from dazzle_dnr_ui.runtime.js_loader import get_runtime_js

        return get_runtime_js(use_esm=False, include_realtime=False)
    except (ImportError, FileNotFoundError):
        # Fall back to inline version
        return _RUNTIME_JS_INLINE


# =============================================================================
# Runtime Template (Inline Fallback)
# =============================================================================

# This is kept for backward compatibility and as a fallback if the modular
# files are not available. The canonical source is now in static/js/*.js
_RUNTIME_JS_INLINE = """
/**
 * DNR-UI Runtime - Minimal reactive UI runtime
 * Generated by Dazzle Native Runtime
 * Version: 0.4.0 (Behaviour Layer Complete)
 */
(function(global) {
  'use strict';

  // ==========================================================================
  // Signals-based Reactivity
  // ==========================================================================

  let currentSubscriber = null;
  const signalDeps = new Map();
  let batchDepth = 0;
  const pendingEffects = new Set();

  function createSignal(initialValue, options = {}) {
    let value = initialValue;
    const subscribers = new Set();
    const { persistent, key, equals } = options;
    const isEqual = equals || ((a, b) => a === b);

    // Load from storage if persistent
    if (persistent && key) {
      const stored = localStorage.getItem(`dnr_${key}`);
      if (stored !== null) {
        try {
          value = JSON.parse(stored);
        } catch (e) {
          console.warn(`Failed to parse stored value for ${key}`, e);
        }
      }
    }

    function getter() {
      if (currentSubscriber) {
        subscribers.add(currentSubscriber);
      }
      return value;
    }

    function setter(newValue) {
      if (typeof newValue === 'function') {
        newValue = newValue(value);
      }
      if (!isEqual(value, newValue)) {
        value = newValue;
        // Persist if needed
        if (persistent && key) {
          localStorage.setItem(`dnr_${key}`, JSON.stringify(value));
        }
        // Notify subscribers
        if (batchDepth > 0) {
          subscribers.forEach(fn => pendingEffects.add(fn));
        } else {
          subscribers.forEach(fn => fn());
        }
      }
    }

    return [getter, setter];
  }

  function batch(fn) {
    batchDepth++;
    try {
      fn();
    } finally {
      batchDepth--;
      if (batchDepth === 0) {
        const effects = Array.from(pendingEffects);
        pendingEffects.clear();
        effects.forEach(fn => fn());
      }
    }
  }

  function createEffect(fn, options = {}) {
    let cleanup = null;
    const { defer = false } = options;

    function execute() {
      if (cleanup && typeof cleanup === 'function') {
        cleanup();
      }
      currentSubscriber = execute;
      try {
        cleanup = fn();
      } finally {
        currentSubscriber = null;
      }
    }

    if (defer) {
      requestAnimationFrame(execute);
    } else {
      execute();
    }

    return function dispose() {
      if (cleanup && typeof cleanup === 'function') {
        cleanup();
      }
    };
  }

  function createMemo(fn, options = {}) {
    const [signal, setSignal] = createSignal(undefined, options);
    createEffect(() => {
      setSignal(fn());
    });
    return signal;
  }

  function createResource(fetcher, options = {}) {
    const [data, setData] = createSignal(options.initialValue);
    const [loading, setLoading] = createSignal(false);
    const [error, setError] = createSignal(null);

    async function refetch(source) {
      setLoading(true);
      setError(null);
      try {
        const result = await fetcher(source);
        setData(result);
        return result;
      } catch (e) {
        setError(e);
        throw e;
      } finally {
        setLoading(false);
      }
    }

    // Auto-fetch if source provided
    if (options.source) {
      refetch(options.source);
    }

    return { data, loading, error, refetch };
  }

  // ==========================================================================
  // State Management
  // ==========================================================================

  const stateStores = {
    local: new Map(),    // Component-local state
    workspace: new Map(), // Workspace-level state
    app: new Map(),      // App-global state
    session: new Map()   // Session-persistent state
  };

  // Global loading and error state
  const [globalLoading, setGlobalLoading] = createSignal(false);
  const [globalError, setGlobalError] = createSignal(null);
  const [notifications, setNotifications] = createSignal([]);

  function getState(scope, path) {
    const store = stateStores[scope];
    if (!store) return undefined;
    const [getter] = store.get(path) || [];
    return getter ? getter() : undefined;
  }

  function setState(scope, path, value) {
    const store = stateStores[scope];
    if (!store) return;
    let [, setter] = store.get(path) || [];
    if (!setter) {
      // Auto-create state if it doesn't exist
      registerState(scope, path, value);
      [, setter] = store.get(path);
    }
    if (setter) setter(value);
  }

  function updateState(scope, path, updater) {
    const store = stateStores[scope];
    if (!store) return;
    const [getter, setter] = store.get(path) || [];
    if (getter && setter) {
      setter(updater(getter()));
    }
  }

  function registerState(scope, path, initial, persistent = false) {
    const store = stateStores[scope];
    if (!store.has(path)) {
      const signal = createSignal(initial, {
        persistent: persistent || scope === 'session',
        key: `${scope}_${path}`
      });
      store.set(path, signal);
    }
    return store.get(path);
  }

  // ==========================================================================
  // API Client
  // ==========================================================================

  const apiClient = {
    baseUrl: '/api',

    async request(method, path, data = null, options = {}) {
      const url = `${this.baseUrl}${path}`;
      const fetchOptions = {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      };

      if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
        fetchOptions.body = JSON.stringify(data);
      }

      const response = await fetch(url, fetchOptions);

      if (!response.ok) {
        const error = new Error(`HTTP ${response.status}`);
        error.status = response.status;
        try {
          error.data = await response.json();
        } catch {
          error.data = null;
        }
        throw error;
      }

      return response.json();
    },

    get(path, options) { return this.request('GET', path, null, options); },
    post(path, data, options) { return this.request('POST', path, data, options); },
    put(path, data, options) { return this.request('PUT', path, data, options); },
    patch(path, data, options) { return this.request('PATCH', path, data, options); },
    delete(path, options) { return this.request('DELETE', path, null, options); },

    // CRUD helpers for entities
    list(entity, params = {}) {
      const query = new URLSearchParams(params).toString();
      return this.get(`/${entity}${query ? '?' + query : ''}`);
    },
    read(entity, id) { return this.get(`/${entity}/${id}`); },
    create(entity, data) { return this.post(`/${entity}`, data); },
    update(entity, id, data) { return this.put(`/${entity}/${id}`, data); },
    remove(entity, id) { return this.delete(`/${entity}/${id}`); }
  };

  // ==========================================================================
  // Toast Notifications
  // ==========================================================================

  let toastContainer = null;

  function ensureToastContainer() {
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.id = 'dnr-toast-container';
      toastContainer.style.cssText = `
        position: fixed;
        top: 16px;
        right: 16px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 8px;
        pointer-events: none;
      `;
      document.body.appendChild(toastContainer);
    }
    return toastContainer;
  }

  function showToast(message, options = {}) {
    const {
      variant = 'info',
      duration = 3000,
      action = null
    } = options;

    const container = ensureToastContainer();

    const toast = document.createElement('div');
    toast.className = `dnr-toast dnr-toast-${variant}`;
    toast.style.cssText = `
      padding: 12px 16px;
      border-radius: 4px;
      background: ${variant === 'success' ? '#28a745' :
                   variant === 'error' ? '#dc3545' :
                   variant === 'warning' ? '#ffc107' : '#17a2b8'};
      color: ${variant === 'warning' ? '#212529' : '#fff'};
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 250px;
      max-width: 400px;
      animation: dnr-toast-in 0.3s ease-out;
    `;

    const messageSpan = document.createElement('span');
    messageSpan.textContent = message;
    messageSpan.style.flex = '1';
    toast.appendChild(messageSpan);

    if (action) {
      const actionBtn = document.createElement('button');
      actionBtn.textContent = action.label;
      actionBtn.onclick = action.onClick;
      actionBtn.style.cssText = `
        background: transparent;
        border: 1px solid currentColor;
        color: inherit;
        padding: 4px 8px;
        border-radius: 2px;
        cursor: pointer;
      `;
      toast.appendChild(actionBtn);
    }

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      background: transparent;
      border: none;
      color: inherit;
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    `;
    closeBtn.onclick = () => removeToast(toast);
    toast.appendChild(closeBtn);

    container.appendChild(toast);

    // Add notification to state
    const notification = { id: Date.now(), message, variant, timestamp: new Date() };
    setNotifications(prev => [...prev, notification]);

    if (duration > 0) {
      setTimeout(() => removeToast(toast, notification.id), duration);
    }

    return notification.id;
  }

  function removeToast(toast, notificationId) {
    toast.style.animation = 'dnr-toast-out 0.2s ease-in forwards';
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 200);

    if (notificationId) {
      setNotifications(prev => prev.filter(n => n.id !== notificationId));
    }
  }

  // Add toast animation styles
  const toastStyles = document.createElement('style');
  toastStyles.textContent = `
    @keyframes dnr-toast-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes dnr-toast-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  `;
  if (typeof document !== 'undefined') {
    document.head.appendChild(toastStyles);
  }

  // ==========================================================================
  // DOM Helpers
  // ==========================================================================

  function createElement(tag, props = {}, children = []) {
    const el = document.createElement(tag);

    Object.entries(props).forEach(([key, value]) => {
      if (key === 'className') {
        el.className = value;
      } else if (key === 'style' && typeof value === 'object') {
        Object.assign(el.style, value);
      } else if (key.startsWith('on') && typeof value === 'function') {
        const event = key.slice(2).toLowerCase();
        el.addEventListener(event, value);
      } else if (key === 'ref' && typeof value === 'function') {
        value(el);
      } else if (value !== null && value !== undefined && value !== false) {
        el.setAttribute(key, value);
      }
    });

    children.forEach(child => {
      if (typeof child === 'string' || typeof child === 'number') {
        el.appendChild(document.createTextNode(String(child)));
      } else if (child instanceof Node) {
        el.appendChild(child);
      } else if (Array.isArray(child)) {
        child.forEach(c => {
          if (c instanceof Node) el.appendChild(c);
          else if (c != null) el.appendChild(document.createTextNode(String(c)));
        });
      }
    });

    return el;
  }

  function render(container, component) {
    container.innerHTML = '';
    if (component instanceof Node) {
      container.appendChild(component);
    } else if (typeof component === 'function') {
      createEffect(() => {
        container.innerHTML = '';
        const result = component();
        if (result instanceof Node) {
          container.appendChild(result);
        }
      });
    }
  }

  // ==========================================================================
  // Binding Resolution
  // ==========================================================================

  function resolveBinding(binding, context) {
    if (!binding || !binding.kind) return binding;

    switch (binding.kind) {
      case 'literal':
        return binding.value;

      case 'prop':
        return getByPath(context.props, binding.path);

      case 'state':
        return getState('local', `${context.componentId}_${binding.path}`);

      case 'workspaceState':
        return getState('workspace', binding.path);

      case 'appState':
        return getState('app', binding.path);

      case 'derived':
        // Simple expression evaluation (be careful with this in production!)
        try {
          return evalExpression(binding.expr, context);
        } catch (e) {
          console.warn('Expression evaluation failed:', binding.expr, e);
          return undefined;
        }

      default:
        return binding;
    }
  }

  function getByPath(obj, path) {
    if (!obj || !path) return undefined;
    return path.split('.').reduce((o, p) => o && o[p], obj);
  }

  function evalExpression(expr, context) {
    // Safe expression evaluation using Function constructor
    // Only allows access to context values
    const fn = new Function('ctx', `with(ctx) { return ${expr}; }`);
    return fn({
      props: context.props || {},
      state: context.state || {},
      workspace: stateStores.workspace,
      app: stateStores.app
    });
  }

  // ==========================================================================
  // Component Registry
  // ==========================================================================

  const componentRegistry = new Map();

  function registerComponent(name, renderFn) {
    componentRegistry.set(name, renderFn);
  }

  function getComponent(name) {
    return componentRegistry.get(name);
  }

  // ==========================================================================
  // Built-in Primitives
  // ==========================================================================

  // Page component
  registerComponent('Page', (props, children) => {
    return createElement('div', {
      className: 'dnr-page',
      style: { padding: 'var(--spacing-md, 16px)' }
    }, [
      props.title ? createElement('h1', { className: 'dnr-page-title' }, [props.title]) : null,
      ...children
    ].filter(Boolean));
  });

  // Card component
  registerComponent('Card', (props, children) => {
    return createElement('div', {
      className: 'dnr-card',
      style: {
        border: '1px solid var(--color-border, #ddd)',
        borderRadius: 'var(--radius-md, 4px)',
        padding: 'var(--spacing-md, 16px)',
        backgroundColor: 'var(--color-surface, #fff)'
      }
    }, [
      props.title ? createElement('h2', { className: 'dnr-card-title' }, [props.title]) : null,
      ...children
    ].filter(Boolean));
  });

  // Text component
  registerComponent('Text', (props, children) => {
    const tag = props.variant === 'heading' ? 'h2' :
                props.variant === 'subheading' ? 'h3' :
                props.variant === 'label' ? 'label' : 'p';
    return createElement(tag, { className: `dnr-text dnr-text-${props.variant || 'body'}` }, children);
  });

  // Button component
  registerComponent('Button', (props, children) => {
    return createElement('button', {
      className: `dnr-button dnr-button-${props.variant || 'default'}`,
      onClick: props.onClick,
      disabled: props.disabled,
      type: props.type || 'button',
      style: {
        padding: 'var(--spacing-sm, 8px) var(--spacing-md, 16px)',
        borderRadius: 'var(--radius-sm, 2px)',
        cursor: props.disabled ? 'not-allowed' : 'pointer'
      }
    }, children.length ? children : [props.label]);
  });

  // Input component
  registerComponent('Input', (props) => {
    return createElement('input', {
      className: 'dnr-input',
      type: props.type || 'text',
      value: props.value,
      placeholder: props.placeholder,
      disabled: props.disabled,
      onInput: (e) => props.onChange && props.onChange(e.target.value),
      style: {
        padding: 'var(--spacing-sm, 8px)',
        border: '1px solid var(--color-border, #ddd)',
        borderRadius: 'var(--radius-sm, 2px)',
        width: '100%'
      }
    });
  });

  // DataTable component
  registerComponent('DataTable', (props) => {
    const { columns, data, onRowClick } = props;

    const thead = createElement('thead', {}, [
      createElement('tr', {}, (columns || []).map(col =>
        createElement('th', { style: { textAlign: 'left', padding: '8px' } }, [col.label || col.key])
      ))
    ]);

    const tbody = createElement('tbody', {}, (data || []).map((row, idx) =>
      createElement('tr', {
        onClick: () => onRowClick && onRowClick(row),
        style: { cursor: onRowClick ? 'pointer' : 'default' }
      }, (columns || []).map(col =>
        createElement('td', { style: { padding: '8px' } }, [row[col.key]])
      ))
    ));

    return createElement('table', {
      className: 'dnr-data-table',
      style: { width: '100%', borderCollapse: 'collapse' }
    }, [thead, tbody]);
  });

  // Form component
  registerComponent('Form', (props, children) => {
    return createElement('form', {
      className: 'dnr-form',
      onSubmit: (e) => {
        e.preventDefault();
        props.onSubmit && props.onSubmit(e);
      }
    }, [
      props.title ? createElement('h2', { className: 'dnr-form-title' }, [props.title]) : null,
      ...children
    ].filter(Boolean));
  });

  // Stack (flexbox) component
  registerComponent('Stack', (props, children) => {
    return createElement('div', {
      className: 'dnr-stack',
      style: {
        display: 'flex',
        flexDirection: props.direction || 'column',
        gap: `var(--spacing-${props.gap || 'md'}, 16px)`,
        alignItems: props.align || 'stretch',
        justifyContent: props.justify || 'flex-start'
      }
    }, children);
  });

  // FilterableTable pattern component
  registerComponent('FilterableTable', (props) => {
    // This is a pattern that combines filter inputs with a data table
    return createElement('div', { className: 'dnr-filterable-table' }, [
      createElement('div', { className: 'dnr-filters', style: { marginBottom: '16px' } }, [
        props.filterPlaceholder ?
          createElement('input', {
            type: 'text',
            placeholder: props.filterPlaceholder,
            style: { padding: '8px', width: '200px' }
          }) : null
      ].filter(Boolean)),
      componentRegistry.get('DataTable')(props)
    ]);
  });

  // Loading indicator
  registerComponent('Loading', (props) => {
    const size = props.size || 24;
    return createElement('div', {
      className: 'dnr-loading',
      style: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      }
    }, [
      createElement('div', {
        className: 'dnr-spinner',
        style: {
          width: `${size}px`,
          height: `${size}px`,
          border: '2px solid var(--color-border)',
          borderTopColor: 'var(--color-primary)',
          borderRadius: '50%',
          animation: 'dnr-spin 0.8s linear infinite'
        }
      }),
      props.text ? createElement('span', {}, [props.text]) : null
    ].filter(Boolean));
  });

  // Error display
  registerComponent('Error', (props) => {
    return createElement('div', {
      className: 'dnr-error',
      style: {
        padding: 'var(--spacing-md)',
        backgroundColor: '#fef2f2',
        border: '1px solid #fecaca',
        borderRadius: 'var(--radius-md)',
        color: '#991b1b'
      }
    }, [
      createElement('strong', {}, [props.title || 'Error']),
      props.message ? createElement('p', { style: { margin: '8px 0 0' } }, [props.message]) : null,
      props.onRetry ? createElement('button', {
        onClick: props.onRetry,
        style: {
          marginTop: '8px',
          padding: '4px 12px',
          background: '#dc3545',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }
      }, ['Retry']) : null
    ].filter(Boolean));
  });

  // Empty state
  registerComponent('Empty', (props) => {
    return createElement('div', {
      className: 'dnr-empty',
      style: {
        textAlign: 'center',
        padding: 'var(--spacing-xl)',
        color: 'var(--color-text-secondary)'
      }
    }, [
      props.icon ? createElement('div', { style: { fontSize: '48px', marginBottom: '16px' } }, [props.icon]) : null,
      createElement('p', {}, [props.message || 'No data available']),
      props.action ? createElement('button', {
        onClick: props.action.onClick,
        className: 'dnr-button dnr-button-primary',
        style: { marginTop: '16px' }
      }, [props.action.label]) : null
    ].filter(Boolean));
  });

  // Modal/Dialog
  registerComponent('Modal', (props, children) => {
    if (!props.open) return null;

    const overlay = createElement('div', {
      className: 'dnr-modal-overlay',
      onClick: (e) => {
        if (e.target === e.currentTarget && props.onClose) props.onClose();
      },
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      }
    }, [
      createElement('div', {
        className: 'dnr-modal',
        style: {
          background: 'var(--color-background)',
          borderRadius: 'var(--radius-lg)',
          padding: 'var(--spacing-lg)',
          maxWidth: props.maxWidth || '500px',
          width: '90%',
          maxHeight: '90vh',
          overflow: 'auto'
        }
      }, [
        createElement('div', {
          className: 'dnr-modal-header',
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 'var(--spacing-md)'
          }
        }, [
          createElement('h2', { style: { margin: 0 } }, [props.title || '']),
          props.onClose ? createElement('button', {
            onClick: props.onClose,
            style: {
              background: 'none',
              border: 'none',
              fontSize: '24px',
              cursor: 'pointer',
              color: 'var(--color-text-secondary)'
            }
          }, ['×']) : null
        ].filter(Boolean)),
        createElement('div', { className: 'dnr-modal-body' }, children)
      ])
    ]);

    return overlay;
  });

  // Add spinner animation
  const spinnerStyle = document.createElement('style');
  spinnerStyle.textContent = `
    @keyframes dnr-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  `;
  if (typeof document !== 'undefined') {
    document.head.appendChild(spinnerStyle);
  }

  // ==========================================================================
  // View Tree Renderer
  // ==========================================================================

  function renderViewNode(node, context) {
    if (!node) return null;

    switch (node.kind) {
      case 'element':
        return renderElementNode(node, context);

      case 'conditional':
        return renderConditionalNode(node, context);

      case 'loop':
        return renderLoopNode(node, context);

      case 'slot':
        return renderSlotNode(node, context);

      case 'text':
        return renderTextNode(node, context);

      default:
        console.warn('Unknown node kind:', node.kind);
        return null;
    }
  }

  function renderElementNode(node, context) {
    const componentName = node.as || node.as_;
    const ComponentFn = componentRegistry.get(componentName);

    // Resolve all props
    const resolvedProps = {};
    Object.entries(node.props || {}).forEach(([key, binding]) => {
      resolvedProps[key] = resolveBinding(binding, context);
    });

    // Render children
    const children = (node.children || []).map(child => renderViewNode(child, context)).filter(Boolean);

    if (ComponentFn) {
      return ComponentFn(resolvedProps, children);
    } else {
      // Fall back to HTML element
      return createElement(componentName.toLowerCase(), resolvedProps, children);
    }
  }

  function renderConditionalNode(node, context) {
    const condition = resolveBinding(node.condition, context);
    if (condition) {
      return renderViewNode(node.then_branch || node.thenBranch, context);
    } else if (node.else_branch || node.elseBranch) {
      return renderViewNode(node.else_branch || node.elseBranch, context);
    }
    return null;
  }

  function renderLoopNode(node, context) {
    const items = resolveBinding(node.items, context) || [];
    const itemVar = node.item_var || node.itemVar || 'item';
    const keyPath = node.key_path || node.keyPath || 'id';

    const fragment = document.createDocumentFragment();
    items.forEach((item, index) => {
      const itemContext = {
        ...context,
        props: {
          ...context.props,
          [itemVar]: item,
          [`${itemVar}Index`]: index
        }
      };
      const child = renderViewNode(node.template, itemContext);
      if (child) {
        child.setAttribute('data-key', getByPath(item, keyPath) || index);
        fragment.appendChild(child);
      }
    });
    return fragment;
  }

  function renderSlotNode(node, context) {
    const slotContent = context.slots && context.slots[node.name];
    if (slotContent) {
      return renderViewNode(slotContent, context);
    } else if (node.fallback) {
      return renderViewNode(node.fallback, context);
    }
    return null;
  }

  function renderTextNode(node, context) {
    const content = resolveBinding(node.content, context);
    return document.createTextNode(String(content || ''));
  }

  // ==========================================================================
  // Theme System
  // ==========================================================================

  function applyTheme(theme) {
    if (!theme || !theme.tokens) return;

    const root = document.documentElement;

    // Apply colors
    Object.entries(theme.tokens.colors || {}).forEach(([name, value]) => {
      root.style.setProperty(`--color-${name}`, value);
    });

    // Apply spacing
    Object.entries(theme.tokens.spacing || {}).forEach(([name, value]) => {
      root.style.setProperty(`--spacing-${name}`, typeof value === 'number' ? `${value}px` : value);
    });

    // Apply radii
    Object.entries(theme.tokens.radii || {}).forEach(([name, value]) => {
      root.style.setProperty(`--radius-${name}`, typeof value === 'number' ? `${value}px` : value);
    });
  }

  // ==========================================================================
  // Action Execution
  // ==========================================================================

  const actionRegistry = new Map();

  function registerAction(name, handler) {
    actionRegistry.set(name, handler);
  }

  function dispatch(actionName, payload = {}) {
    const handler = actionRegistry.get(actionName);
    if (handler) {
      return handler(payload);
    }
    console.warn(`Action not found: ${actionName}`);
  }

  async function executeAction(action, context) {
    if (!action) return;

    const actionName = typeof action === 'string' ? action : action.name;

    // Check for registered actions first
    if (actionRegistry.has(actionName)) {
      return dispatch(actionName, context.payload || context.data || {});
    }

    // Apply state transitions with batch for performance
    if (action.transitions && action.transitions.length > 0) {
      batch(() => {
        action.transitions.forEach(transition => {
          const scope = transition.scope || 'local';
          const targetState = transition.target_state || transition.targetState;
          const path = scope === 'local' ?
            `${context.componentId}_${targetState}` : targetState;

          // Handle patch operations
          const update = transition.update;
          if (update && update.op) {
            applyPatch(scope, path, update, context);
          } else {
            // Simple set
            const value = resolveBinding(transition.value || update, context);
            setState(scope, path, value);
          }
        });
      });
    }

    // Execute effect
    if (action.effect) {
      await executeEffect(action.effect, context);
    }
  }

  function applyPatch(scope, path, patch, context) {
    const value = resolveBinding(patch.value, context);

    switch (patch.op) {
      case 'set':
        setState(scope, path, value);
        break;

      case 'merge':
        updateState(scope, path, current => ({ ...current, ...value }));
        break;

      case 'append':
        updateState(scope, path, current => Array.isArray(current) ? [...current, value] : [value]);
        break;

      case 'remove':
        updateState(scope, path, current => {
          if (Array.isArray(current)) {
            return current.filter(item => {
              if (typeof value === 'function') return !value(item);
              if (typeof value === 'object' && value.id) return item.id !== value.id;
              return item !== value;
            });
          }
          return current;
        });
        break;

      case 'delete':
        setState(scope, path, undefined);
        break;
    }
  }

  async function executeEffect(effect, context) {
    if (!effect) return;

    switch (effect.kind) {
      case 'fetch': {
        const service = effect.backend_service || effect.backendService;
        const method = effect.method || 'GET';
        const inputs = {};

        // Resolve input bindings
        Object.entries(effect.inputs || {}).forEach(([key, binding]) => {
          inputs[key] = resolveBinding(binding, context);
        });

        setGlobalLoading(true);
        setGlobalError(null);

        try {
          let result;
          const entity = service.replace(/_service$/, 's');

          // Map to appropriate API call based on method
          if (method === 'GET' || effect.operation === 'list') {
            result = await apiClient.list(entity, inputs);
          } else if (effect.operation === 'read' && inputs.id) {
            result = await apiClient.read(entity, inputs.id);
          } else if (method === 'POST' || effect.operation === 'create') {
            result = await apiClient.create(entity, inputs);
          } else if (method === 'PUT' || effect.operation === 'update') {
            result = await apiClient.update(entity, inputs.id, inputs);
          } else if (method === 'DELETE' || effect.operation === 'delete') {
            result = await apiClient.remove(entity, inputs.id);
          } else {
            // Generic fetch
            result = await apiClient.request(method, `/${service}`, inputs);
          }

          // Handle success
          if (effect.on_success || effect.onSuccess) {
            const successAction = context.getAction ?
              context.getAction(effect.on_success || effect.onSuccess) :
              { name: effect.on_success || effect.onSuccess };

            if (successAction) {
              await executeAction(successAction, { ...context, data: result, result });
            }
          }

          return result;
        } catch (error) {
          setGlobalError(error);
          console.error('Fetch effect failed:', error);

          // Handle error
          if (effect.on_error || effect.onError) {
            const errorAction = context.getAction ?
              context.getAction(effect.on_error || effect.onError) :
              { name: effect.on_error || effect.onError };

            if (errorAction) {
              await executeAction(errorAction, { ...context, error });
            }
          } else {
            // Default error handling
            showToast(error.message || 'An error occurred', { variant: 'error' });
          }
        } finally {
          setGlobalLoading(false);
        }
        break;
      }

      case 'navigate': {
        const route = effect.route;
        const params = {};
        Object.entries(effect.params || {}).forEach(([key, binding]) => {
          params[key] = resolveBinding(binding, context);
        });

        // Replace route params
        let url = route;
        Object.entries(params).forEach(([key, value]) => {
          url = url.replace(`{${key}}`, encodeURIComponent(value));
          url = url.replace(`:${key}`, encodeURIComponent(value));
        });

        window.history.pushState({ params }, '', url);
        window.dispatchEvent(new CustomEvent('dnr-navigate', { detail: { url, params } }));
        break;
      }

      case 'log': {
        const message = resolveBinding(effect.message, context);
        const level = effect.level || 'info';
        console[level](message);
        break;
      }

      case 'toast': {
        const message = resolveBinding(effect.message, context);
        showToast(message, {
          variant: effect.variant || 'info',
          duration: effect.duration || 3000
        });
        break;
      }

      case 'custom': {
        const handler = actionRegistry.get(`effect:${effect.name}`);
        if (handler) {
          await handler(effect.config, context);
        } else {
          console.warn(`Custom effect not found: ${effect.name}`);
        }
        break;
      }
    }
  }

  // ==========================================================================
  // Built-in Actions
  // ==========================================================================

  // Pure actions (state only, no side effects)
  registerAction('filter', ({ items, predicate, target }) => {
    if (!items || !predicate) return items;
    const filtered = items.filter(predicate);
    if (target) setState('workspace', target, filtered);
    return filtered;
  });

  registerAction('sort', ({ items, key, direction = 'asc', target }) => {
    if (!items || !key) return items;
    const sorted = [...items].sort((a, b) => {
      const aVal = a[key];
      const bVal = b[key];
      const cmp = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
      return direction === 'desc' ? -cmp : cmp;
    });
    if (target) setState('workspace', target, sorted);
    return sorted;
  });

  registerAction('select', ({ item, target }) => {
    if (target) setState('workspace', target, item);
    return item;
  });

  registerAction('toggle', ({ path, scope = 'workspace' }) => {
    updateState(scope, path, current => !current);
  });

  registerAction('reset', ({ path, scope = 'workspace', initial = null }) => {
    setState(scope, path, initial);
  });

  // ==========================================================================
  // Application Bootstrap
  // ==========================================================================

  function createApp(uiSpec) {
    // Register custom components from spec
    (uiSpec.components || []).forEach(comp => {
      if (comp.view && !componentRegistry.has(comp.name)) {
        registerComponent(comp.name, (props, children) => {
          // Initialize component state
          (comp.state || []).forEach(stateSpec => {
            const scope = stateSpec.scope || 'local';
            const path = scope === 'local' ? `${comp.name}_${stateSpec.name}` : stateSpec.name;
            registerState(scope, path, stateSpec.initial, stateSpec.persistent);
          });

          // Build context
          const context = {
            componentId: comp.name,
            props,
            slots: {},
            getAction: (name) => (comp.actions || []).find(a => a.name === name)
          };

          // Render view tree
          return renderViewNode(comp.view, context);
        });
      }
    });

    // Apply default theme
    if (uiSpec.default_theme || uiSpec.defaultTheme) {
      const themeName = uiSpec.default_theme || uiSpec.defaultTheme;
      const theme = (uiSpec.themes || []).find(t => t.name === themeName);
      if (theme) applyTheme(theme);
    }

    return {
      mount(container, workspaceName) {
        const workspace = (uiSpec.workspaces || []).find(w => w.name === workspaceName);
        if (!workspace) {
          console.error(`Workspace "${workspaceName}" not found`);
          return;
        }

        // Initialize workspace state
        (workspace.state || []).forEach(stateSpec => {
          registerState('workspace', stateSpec.name, stateSpec.initial, stateSpec.persistent);
        });

        // Render workspace routes
        const defaultRoute = workspace.routes && workspace.routes[0];
        if (defaultRoute) {
          const ComponentFn = componentRegistry.get(defaultRoute.component);
          if (ComponentFn) {
            render(container, () => ComponentFn({}, []));
          }
        }
      },

      navigate(route) {
        window.history.pushState({}, '', route);
        window.dispatchEvent(new CustomEvent('dnr-navigate', { detail: { url: route } }));
      },

      getState,
      setState,
      registerComponent,
      applyTheme
    };
  }

  // Export to global
  global.DNR = {
    // Signals & Reactivity
    createSignal,
    createEffect,
    createMemo,
    createResource,
    batch,

    // State Management
    getState,
    setState,
    updateState,
    registerState,
    globalLoading,
    globalError,
    notifications,

    // DOM
    createElement,
    render,

    // Components
    registerComponent,
    getComponent,

    // Actions & Effects
    registerAction,
    dispatch,
    executeAction,
    executeEffect,

    // Notifications
    showToast,

    // API Client
    api: apiClient,

    // Theme
    applyTheme,

    // App
    createApp
  };

})(typeof window !== 'undefined' ? window : global);
"""

# Lazy-loaded runtime JS (loaded from files on first access)
_RUNTIME_JS_CACHED: str | None = None


def _get_runtime_js() -> str:
    """Get the runtime JS, loading from files if available."""
    global _RUNTIME_JS_CACHED
    if _RUNTIME_JS_CACHED is None:
        _RUNTIME_JS_CACHED = _load_runtime_js()
    return _RUNTIME_JS_CACHED


def get_runtime_js() -> str:
    """
    Get the DNR-UI runtime JavaScript.

    Public function for accessing the runtime JS. Loads from modular
    files in static/js/ if available, otherwise falls back to inline.

    Returns:
        Runtime JavaScript code
    """
    return _get_runtime_js()


# Backward compatibility - direct string access
# NOTE: This is the inline fallback for code that imports RUNTIME_JS directly
RUNTIME_JS = _RUNTIME_JS_INLINE


# =============================================================================
# JavaScript Generator
# =============================================================================


class JSGenerator:
    """
    Generates JavaScript code from UISpec.

    Creates pure JavaScript that can run in any browser without frameworks.
    """

    def __init__(self, spec: UISpec):
        """
        Initialize the generator.

        Args:
            spec: UI specification
        """
        self.spec = spec

    def generate_runtime(self) -> str:
        """
        Get the DNR-UI runtime JavaScript.

        Loads from modular files in static/js/ if available,
        otherwise falls back to the inline version.

        Returns:
            Runtime JavaScript code
        """
        return _get_runtime_js()

    def generate_spec_json(self) -> str:
        """
        Generate JSON representation of the UISpec.

        Returns:
            JSON string
        """
        import json

        return json.dumps(self.spec.model_dump(by_alias=True), indent=2)

    def generate_app_js(self) -> str:
        """
        Generate the application JavaScript.

        Returns:
            JavaScript code that initializes the app
        """
        spec_json = self.generate_spec_json()

        return f"""
// DNR-UI Application - Generated by Dazzle Native Runtime
(function() {{
  'use strict';

  // UISpec data
  const uiSpec = {spec_json};

  // Initialize app on DOM ready
  document.addEventListener('DOMContentLoaded', function() {{
    const app = DNR.createApp(uiSpec);

    // Mount default workspace
    const container = document.getElementById('app') || document.body;
    const defaultWorkspace = uiSpec.default_workspace || uiSpec.defaultWorkspace ||
                            (uiSpec.workspaces && uiSpec.workspaces[0] && uiSpec.workspaces[0].name);

    if (defaultWorkspace) {{
      app.mount(container, defaultWorkspace);
    }}

    // Export app to window for debugging
    window.dnrApp = app;
  }});
}})();
"""

    def generate_html(
        self,
        title: str | None = None,
        include_runtime: bool = True,
    ) -> str:
        """
        Generate a complete HTML page.

        Args:
            title: Page title (defaults to spec name)
            include_runtime: Whether to include runtime inline

        Returns:
            Complete HTML document
        """
        title = title or self.spec.name or "DNR UI"
        runtime_js = self.generate_runtime() if include_runtime else ""
        app_js = self.generate_app_js()

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{title}</title>
  <style>
    /* DNR-UI Base Styles */
    :root {{
      --color-primary: #0066cc;
      --color-secondary: #6c757d;
      --color-success: #28a745;
      --color-danger: #dc3545;
      --color-warning: #ffc107;
      --color-info: #17a2b8;
      --color-background: #ffffff;
      --color-surface: #f8f9fa;
      --color-text: #212529;
      --color-text-secondary: #6c757d;
      --color-border: #dee2e6;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      --radius-sm: 2px;
      --radius-md: 4px;
      --radius-lg: 8px;
    }}

    * {{
      box-sizing: border-box;
    }}

    body {{
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--color-background);
      color: var(--color-text);
      line-height: 1.5;
    }}

    #app {{
      min-height: 100vh;
    }}

    /* DNR Component Styles */
    .dnr-page {{
      padding: var(--spacing-md);
    }}

    .dnr-page-title {{
      margin: 0 0 var(--spacing-md) 0;
      font-size: 1.5rem;
    }}

    .dnr-card {{
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }}

    .dnr-card-title {{
      margin: 0 0 var(--spacing-sm) 0;
      font-size: 1.25rem;
    }}

    .dnr-button {{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      background: var(--color-surface);
      color: var(--color-text);
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.2s;
    }}

    .dnr-button:hover {{
      background: var(--color-background);
    }}

    .dnr-button-primary {{
      background: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }}

    .dnr-button-primary:hover {{
      background: #0056b3;
    }}

    .dnr-input {{
      padding: var(--spacing-sm);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      font-size: 1rem;
      width: 100%;
    }}

    .dnr-input:focus {{
      outline: none;
      border-color: var(--color-primary);
    }}

    .dnr-data-table {{
      width: 100%;
      border-collapse: collapse;
    }}

    .dnr-data-table th,
    .dnr-data-table td {{
      padding: var(--spacing-sm);
      text-align: left;
      border-bottom: 1px solid var(--color-border);
    }}

    .dnr-data-table tr:hover {{
      background: var(--color-surface);
    }}

    .dnr-form {{
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }}

    .dnr-stack {{
      display: flex;
    }}
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
{runtime_js}
  </script>
  <script>
{app_js}
  </script>
</body>
</html>
"""

    def write_to_directory(
        self,
        output_dir: str | Path,
        split_files: bool = True,
    ) -> list[Path]:
        """
        Write generated files to a directory.

        Args:
            output_dir: Output directory path
            split_files: Whether to split into multiple files

        Returns:
            List of created file paths
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        created_files: list[Path] = []

        if split_files:
            # Write runtime
            runtime_path = output_dir / "dnr-runtime.js"
            runtime_path.write_text(self.generate_runtime())
            created_files.append(runtime_path)

            # Write spec
            spec_path = output_dir / "ui-spec.json"
            spec_path.write_text(self.generate_spec_json())
            created_files.append(spec_path)

            # Write app
            app_path = output_dir / "app.js"
            app_path.write_text(self.generate_app_js())
            created_files.append(app_path)

            # Write HTML with script references
            html = self.generate_html(include_runtime=False)
            html = html.replace(
                "<script>\n\n  </script>\n  <script>",
                '<script src="dnr-runtime.js"></script>\n  <script src="app.js"></script>\n  <script>',
            )
            # Remove the now-empty inline script that follows
            html = html.replace(
                '<script src="app.js"></script>\n  <script>\n\n  </script>',
                '<script src="app.js"></script>',
            )
            html_path = output_dir / "index.html"
            html_path.write_text(html)
            created_files.append(html_path)
        else:
            # Single HTML file with everything inline
            html_path = output_dir / "index.html"
            html_path.write_text(self.generate_html())
            created_files.append(html_path)

        return created_files


# =============================================================================
# Convenience Functions
# =============================================================================


def generate_js_app(spec: UISpec, output_dir: str | Path) -> list[Path]:
    """
    Generate a complete JavaScript application from UISpec.

    Args:
        spec: UI specification
        output_dir: Output directory

    Returns:
        List of created file paths
    """
    generator = JSGenerator(spec)
    return generator.write_to_directory(output_dir, split_files=True)


def generate_single_html(spec: UISpec) -> str:
    """
    Generate a single HTML file with all code inline.

    Args:
        spec: UI specification

    Returns:
        Complete HTML document
    """
    generator = JSGenerator(spec)
    return generator.generate_html(include_runtime=True)
