"""
Docker runner for DNR applications.

Provides docker-first infrastructure for running DNR applications in containers.
This is the default way to run Dazzle apps in development.

Usage:
    from dazzle_dnr_ui.runtime.docker_runner import run_in_docker, is_docker_available

    if is_docker_available():
        run_in_docker(project_path, frontend_port=3000, api_port=8000)
    else:
        # Fall back to local execution
        run_local(...)
"""

from __future__ import annotations

import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    pass


# =============================================================================
# Docker Availability Check
# =============================================================================


def is_docker_available() -> bool:
    """
    Check if Docker is available on the system.

    Returns:
        True if Docker is installed and the daemon is running
    """
    try:
        result = subprocess.run(
            ["docker", "info"],
            capture_output=True,
            timeout=5,
        )
        return result.returncode == 0
    except (subprocess.SubprocessError, FileNotFoundError, subprocess.TimeoutExpired):
        return False


def get_docker_version() -> str | None:
    """
    Get the Docker version string.

    Returns:
        Docker version string or None if not available
    """
    try:
        result = subprocess.run(
            ["docker", "--version"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            return result.stdout.strip()
        return None
    except (subprocess.SubprocessError, FileNotFoundError, subprocess.TimeoutExpired):
        return None


# =============================================================================
# Dockerfile Generation
# =============================================================================


DNR_DOCKERFILE_TEMPLATE = """# DNR Runtime Container
# Generated by Dazzle Native Runtime
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies (minimal runtime only)
RUN pip install --no-cache-dir \\
    fastapi \\
    uvicorn[standard] \\
    aiosqlite \\
    pydantic

# Copy pre-generated specs and entrypoint
COPY backend_spec.json ./
COPY ui_spec.json ./
COPY static/ ./static/
COPY entrypoint.py ./

# Create data directory
RUN mkdir -p /app/.dazzle

# Expose ports (frontend and API)
EXPOSE {frontend_port} {api_port}

# Environment variables
ENV PYTHONUNBUFFERED=1
ENV DNR_HOST=0.0.0.0
ENV DNR_FRONTEND_PORT={frontend_port}
ENV DNR_API_PORT={api_port}
ENV DNR_DB_PATH=/app/.dazzle/data.db
ENV DNR_TEST_MODE=0

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \\
    CMD curl -f http://localhost:{api_port}/health || exit 1

# Run the entrypoint
CMD ["python", "entrypoint.py"]
"""


def generate_dockerfile(
    frontend_port: int = 3000,
    api_port: int = 8000,
) -> str:
    """
    Generate a Dockerfile for DNR runtime.

    Args:
        frontend_port: Frontend server port
        api_port: Backend API port

    Returns:
        Dockerfile content
    """
    return DNR_DOCKERFILE_TEMPLATE.format(
        frontend_port=frontend_port,
        api_port=api_port,
    )


# Entrypoint script that runs inside the container
DNR_ENTRYPOINT_TEMPLATE = '''#!/usr/bin/env python3
"""
DNR Docker Entrypoint - Self-contained runtime for Docker containers.

Loads pre-generated specs and runs a minimal FastAPI server.
"""

import json
import os
import asyncio
from pathlib import Path
from typing import Any

# FastAPI and Uvicorn
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles

import uvicorn

# Configuration from environment
API_PORT = int(os.environ.get("DNR_API_PORT", 8000))
FRONTEND_PORT = int(os.environ.get("DNR_FRONTEND_PORT", 3000))
HOST = os.environ.get("DNR_HOST", "0.0.0.0")
DB_PATH = os.environ.get("DNR_DB_PATH", "/app/.dazzle/data.db")
TEST_MODE = os.environ.get("DNR_TEST_MODE", "0") == "1"

# Load specs
with open("backend_spec.json") as f:
    BACKEND_SPEC = json.load(f)
with open("ui_spec.json") as f:
    UI_SPEC = json.load(f)

# In-memory data store (simple dict-based storage)
DATA_STORE: dict[str, dict[str, Any]] = {}


def get_entity_config(entity_name: str) -> dict | None:
    """Get entity configuration from backend spec."""
    for entity in BACKEND_SPEC.get("entities", []):
        if entity.get("name") == entity_name:
            return entity
    return None


def get_collection(entity_name: str) -> dict[str, Any]:
    """Get or create collection for entity."""
    if entity_name not in DATA_STORE:
        DATA_STORE[entity_name] = {}
    return DATA_STORE[entity_name]


# Create FastAPI app
app = FastAPI(
    title=BACKEND_SPEC.get("name", "DNR API"),
    description="Auto-generated API from Dazzle DSL",
    version="1.0.0",
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy", "mode": "docker"}


@app.get("/api/ui-spec")
async def get_ui_spec():
    """Return the UI specification."""
    return UI_SPEC


# Dynamic entity CRUD endpoints
for entity in BACKEND_SPEC.get("entities", []):
    entity_name = entity["name"]
    route_prefix = f"/api/{entity_name.lower()}s"

    # Create closure to capture entity_name
    def make_crud_handlers(ename: str):
        async def list_items():
            collection = get_collection(ename)
            items = list(collection.values())
            return {"items": items, "total": len(items)}

        async def create_item(request: Request):
            import uuid
            data = await request.json()
            item_id = str(uuid.uuid4())
            data["id"] = item_id
            collection = get_collection(ename)
            collection[item_id] = data
            return data

        async def get_item(item_id: str):
            collection = get_collection(ename)
            if item_id not in collection:
                raise HTTPException(status_code=404, detail=f"{ename} not found")
            return collection[item_id]

        async def update_item(item_id: str, request: Request):
            collection = get_collection(ename)
            if item_id not in collection:
                raise HTTPException(status_code=404, detail=f"{ename} not found")
            data = await request.json()
            data["id"] = item_id
            collection[item_id].update(data)
            return collection[item_id]

        async def delete_item(item_id: str):
            collection = get_collection(ename)
            if item_id not in collection:
                raise HTTPException(status_code=404, detail=f"{ename} not found")
            del collection[item_id]
            return {"deleted": True}

        return list_items, create_item, get_item, update_item, delete_item

    list_h, create_h, get_h, update_h, delete_h = make_crud_handlers(entity_name)

    # Register routes
    app.get(route_prefix)(list_h)
    app.post(route_prefix)(create_h)
    app.get(f"{route_prefix}/{{item_id}}")(get_h)
    app.put(f"{route_prefix}/{{item_id}}")(update_h)
    app.delete(f"{route_prefix}/{{item_id}}")(delete_h)


# Test mode endpoints
if TEST_MODE:
    @app.post("/__test__/reset")
    async def test_reset():
        """Reset all data."""
        DATA_STORE.clear()
        return {"reset": True}

    @app.post("/__test__/seed")
    async def test_seed(request: Request):
        """Seed data."""
        data = await request.json()
        for entity_name, items in data.items():
            collection = get_collection(entity_name)
            for item in items:
                if "id" not in item:
                    import uuid
                    item["id"] = str(uuid.uuid4())
                collection[item["id"]] = item
        return {"seeded": True}


# Static files / UI serving
static_dir = Path("/app/static")
if static_dir.exists():
    @app.get("/", response_class=HTMLResponse)
    async def serve_ui():
        return (static_dir / "index.html").read_text()

    @app.get("/{path:path}")
    async def serve_static(path: str):
        file_path = static_dir / path
        if file_path.exists() and file_path.is_file():
            return FileResponse(file_path)
        # SPA fallback
        return HTMLResponse((static_dir / "index.html").read_text())


if __name__ == "__main__":
    print(f"[DNR] Starting server on {HOST}:{API_PORT}")
    print(f"[DNR] Test mode: {TEST_MODE}")
    print(f"[DNR] Entities: {[e['name'] for e in BACKEND_SPEC.get('entities', [])]}")
    uvicorn.run(app, host=HOST, port=API_PORT)
'''


DNR_DOCKERIGNORE = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/
ENV/
.venv

# Build
build/
dist/
*.egg-info/

# Testing
.pytest_cache/
.coverage
htmlcov/
.hypothesis/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Git
.git/
.gitignore

# Dazzle artifacts (keep dsl/ and dazzle.toml)
.dazzle/

# Misc
.DS_Store
*.log
.env
.env.*
!.env.example
"""


# =============================================================================
# Docker Runner
# =============================================================================


@dataclass
class DockerRunConfig:
    """Configuration for running DNR in Docker."""

    project_path: Path
    frontend_port: int = 3000
    api_port: int = 8000
    container_name: str | None = None
    image_name: str = "dazzle-dnr"
    test_mode: bool = False
    rebuild: bool = False
    detach: bool = False


class DockerRunner:
    """
    Runs DNR applications in Docker containers.

    Provides docker-first infrastructure for Dazzle development.
    """

    def __init__(self, config: DockerRunConfig):
        """
        Initialize the Docker runner.

        Args:
            config: Docker run configuration
        """
        self.config = config
        self.project_path = config.project_path.resolve()

        # Derive container name from project directory
        if config.container_name:
            self.container_name = config.container_name
        else:
            self.container_name = f"dazzle-{self.project_path.name}"

        # Image name includes project context
        self.image_name = f"{config.image_name}:{self.project_path.name}"

    def run(self) -> int:
        """
        Run the DNR application in a Docker container.

        Returns:
            Exit code from Docker run
        """
        print("\n" + "=" * 60)
        print("  DAZZLE NATIVE RUNTIME (DNR) - Docker Mode")
        print("=" * 60)
        print()

        # Check Docker availability
        if not is_docker_available():
            print("[DNR] ERROR: Docker is not available")
            print("[DNR] Please install Docker or use --local flag")
            return 1

        # Stop any existing container with same name
        self._stop_existing_container()

        # Build image if needed
        if self.config.rebuild or not self._image_exists():
            if not self._build_image():
                return 1

        # Run container
        return self._run_container()

    def _image_exists(self) -> bool:
        """Check if the Docker image already exists."""
        try:
            result = subprocess.run(
                ["docker", "image", "inspect", self.image_name],
                capture_output=True,
                timeout=10,
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False

    def _stop_existing_container(self) -> None:
        """Stop and remove any existing container with the same name."""
        try:
            subprocess.run(
                ["docker", "stop", self.container_name],
                capture_output=True,
                timeout=10,
            )
            subprocess.run(
                ["docker", "rm", self.container_name],
                capture_output=True,
                timeout=10,
            )
        except (subprocess.SubprocessError, FileNotFoundError):
            pass  # Container may not exist

    def _build_image(self) -> bool:
        """
        Build the Docker image.

        Returns:
            True if build succeeded
        """
        print(f"[DNR] Building Docker image: {self.image_name}")
        print()

        # First, generate the specs from DSL
        print("[DNR] Generating specs from DSL...")
        try:
            backend_spec, ui_spec, html_content = self._generate_specs()
        except Exception as e:
            print(f"[DNR] ERROR: Failed to generate specs: {e}")
            return False

        # Create temporary build context
        with tempfile.TemporaryDirectory() as tmpdir:
            build_dir = Path(tmpdir)

            # Generate Dockerfile
            dockerfile_content = generate_dockerfile(
                frontend_port=self.config.frontend_port,
                api_port=self.config.api_port,
            )
            (build_dir / "Dockerfile").write_text(dockerfile_content)

            # Generate .dockerignore
            (build_dir / ".dockerignore").write_text(DNR_DOCKERIGNORE)

            # Write pre-generated specs
            import json

            (build_dir / "backend_spec.json").write_text(json.dumps(backend_spec, indent=2))
            (build_dir / "ui_spec.json").write_text(json.dumps(ui_spec, indent=2))

            # Create static directory and write HTML
            static_dir = build_dir / "static"
            static_dir.mkdir(exist_ok=True)
            (static_dir / "index.html").write_text(html_content)

            # Write entrypoint
            (build_dir / "entrypoint.py").write_text(DNR_ENTRYPOINT_TEMPLATE)

            # Build image
            try:
                result = subprocess.run(
                    [
                        "docker",
                        "build",
                        "-t",
                        self.image_name,
                        str(build_dir),
                    ],
                    timeout=300,  # 5 minute timeout
                )
                if result.returncode != 0:
                    print("[DNR] ERROR: Docker build failed")
                    return False
            except subprocess.TimeoutExpired:
                print("[DNR] ERROR: Docker build timed out")
                return False
            except FileNotFoundError:
                print("[DNR] ERROR: Docker not found")
                return False

        print()
        print(f"[DNR] Image built: {self.image_name}")
        return True

    def _generate_specs(self) -> tuple[dict, dict, str]:
        """
        Generate backend spec, UI spec, and HTML from DSL files.

        Returns:
            Tuple of (backend_spec_dict, ui_spec_dict, html_content)
        """
        from dazzle.cli import (
            build_appspec,
            discover_dsl_files,
            load_manifest,
            parse_modules,
        )
        from dazzle_dnr_back.converters import convert_appspec_to_backend
        from dazzle_dnr_ui.converters import convert_appspec_to_ui
        from dazzle_dnr_ui.runtime import generate_single_html

        manifest_path = self.project_path / "dazzle.toml"
        mf = load_manifest(manifest_path)
        dsl_files = discover_dsl_files(self.project_path, mf)
        modules = parse_modules(dsl_files)
        appspec = build_appspec(modules, mf.project_root)

        # Convert to backend and UI specs
        backend_spec = convert_appspec_to_backend(appspec)
        ui_spec = convert_appspec_to_ui(appspec)

        # Generate HTML
        html_content = generate_single_html(ui_spec)

        return (
            backend_spec.model_dump(by_alias=True),
            ui_spec.model_dump(by_alias=True),
            html_content,
        )

    def _run_container(self) -> int:
        """
        Run the Docker container.

        Returns:
            Exit code from docker run
        """
        print()
        print(f"[DNR] Starting container: {self.container_name}")
        print()

        # Build docker run command
        cmd = [
            "docker",
            "run",
            "--name",
            self.container_name,
            "-p",
            f"{self.config.frontend_port}:{self.config.frontend_port}",
            "-p",
            f"{self.config.api_port}:{self.config.api_port}",
        ]

        # Mount data directory for persistence
        data_dir = self.project_path / ".dazzle"
        data_dir.mkdir(exist_ok=True)
        cmd.extend(["-v", f"{data_dir}:/app/.dazzle"])

        # Add test mode if enabled
        if self.config.test_mode:
            cmd.extend(["-e", "DNR_TEST_MODE=1"])

        # Detach mode or interactive mode
        if self.config.detach:
            cmd.append("-d")
        else:
            # Only use -it if we have a TTY, otherwise just run attached
            import sys

            if sys.stdin.isatty():
                cmd.append("-it")
            cmd.append("--rm")

        # Add image name
        cmd.append(self.image_name)

        # Note: Test mode is handled via DNR_TEST_MODE environment variable
        # The entrypoint.py script reads this and enables test endpoints

        print(f"[DNR] Frontend: http://localhost:{self.config.frontend_port}")
        print(f"[DNR] API Docs: http://localhost:{self.config.api_port}/docs")
        print()

        if self.config.detach:
            print(f"[DNR] Running in background (container: {self.container_name})")
            print(f"[DNR] Stop with: docker stop {self.container_name}")
        else:
            print("Press Ctrl+C to stop")
            print("-" * 60)

        print()

        try:
            result = subprocess.run(cmd)
            return result.returncode
        except KeyboardInterrupt:
            print("\n[DNR] Shutting down...")
            self._stop_existing_container()
            return 0


# =============================================================================
# Convenience Functions
# =============================================================================


def run_in_docker(
    project_path: Path | str,
    frontend_port: int = 3000,
    api_port: int = 8000,
    test_mode: bool = False,
    rebuild: bool = False,
    detach: bool = False,
) -> int:
    """
    Run a DNR application in Docker.

    Args:
        project_path: Path to the Dazzle project
        frontend_port: Frontend server port
        api_port: Backend API port
        test_mode: Enable test endpoints
        rebuild: Force rebuild of Docker image
        detach: Run in background

    Returns:
        Exit code
    """
    config = DockerRunConfig(
        project_path=Path(project_path),
        frontend_port=frontend_port,
        api_port=api_port,
        test_mode=test_mode,
        rebuild=rebuild,
        detach=detach,
    )
    runner = DockerRunner(config)
    return runner.run()


def stop_docker_container(project_path: Path | str) -> bool:
    """
    Stop a running DNR Docker container.

    Args:
        project_path: Path to the Dazzle project

    Returns:
        True if container was stopped
    """
    container_name = f"dazzle-{Path(project_path).resolve().name}"
    try:
        result = subprocess.run(
            ["docker", "stop", container_name],
            capture_output=True,
            timeout=10,
        )
        return result.returncode == 0
    except (subprocess.SubprocessError, FileNotFoundError):
        return False
