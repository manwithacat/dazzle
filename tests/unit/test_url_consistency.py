"""Tests for URL prefix consistency and post-create HX-Redirect.

Ensures that page URLs generated by the template compiler match the
router mount prefix, and that HTMX create responses redirect to the
detail page.
"""

from __future__ import annotations

from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

import pytest

from dazzle.core.ir import (
    AppSpec,
    DomainSpec,
    EntitySpec,
    FieldModifier,
    FieldSpec,
    FieldType,
    FieldTypeKind,
    SurfaceElement,
    SurfaceMode,
    SurfaceSection,
    SurfaceSpec,
    WorkspaceSpec,
)

pytest.importorskip("dazzle_ui.converters.template_compiler")

from dazzle_ui.converters.template_compiler import (  # noqa: E402
    compile_appspec_to_templates,
    compile_surface_to_context,
)

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _task_entity() -> EntitySpec:
    return EntitySpec(
        name="Task",
        title="Task",
        fields=[
            FieldSpec(
                name="id",
                type=FieldType(kind=FieldTypeKind.UUID),
                modifiers=[FieldModifier.PK],
            ),
            FieldSpec(
                name="title",
                type=FieldType(kind=FieldTypeKind.STR, max_length=200),
                modifiers=[FieldModifier.REQUIRED],
            ),
            FieldSpec(
                name="completed",
                type=FieldType(kind=FieldTypeKind.BOOL),
                default=False,
            ),
        ],
    )


def _list_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_list",
        title="Tasks",
        entity_ref="Task",
        mode=SurfaceMode.LIST,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _create_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_create",
        title="Create Task",
        entity_ref="Task",
        mode=SurfaceMode.CREATE,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _edit_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_edit",
        title="Edit Task",
        entity_ref="Task",
        mode=SurfaceMode.EDIT,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _view_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_view",
        title="Task Details",
        entity_ref="Task",
        mode=SurfaceMode.VIEW,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _make_appspec() -> AppSpec:
    entity = _task_entity()
    return AppSpec(
        name="test_app",
        title="Test App",
        domain=DomainSpec(entities=[entity]),
        surfaces=[
            _list_surface(),
            _create_surface(),
            _edit_surface(),
            _view_surface(),
        ],
        workspaces=[
            WorkspaceSpec(name="main", title="Main"),
        ],
    )


# ===================================================================
# 1. URL prefix consistency — compile_appspec_to_templates
# ===================================================================


class TestUrlPrefixConsistency:
    """Verify that app_prefix is applied to all page URLs but not API paths."""

    def test_route_keys_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        for route_path in contexts:
            if route_path != "/":
                assert route_path.startswith("/app/"), f"Route {route_path!r} missing /app prefix"

    def test_list_context_urls_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert list_ctx.table.create_url == "/app/task/create"
        assert list_ctx.table.detail_url_template == "/app/task/{id}"

    def test_list_context_api_endpoint_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert not list_ctx.table.api_endpoint.startswith("/app")

    def test_create_context_cancel_url_matches_list_route(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert create_ctx.form.cancel_url == "/app/task"
        # cancel_url must be a valid route
        assert "/app/task" in contexts

    def test_create_context_action_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert not create_ctx.form.action_url.startswith("/app")

    def test_edit_context_cancel_url_uses_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        edit_ctx = contexts["/app/task/{id}/edit"]
        assert edit_ctx.form is not None
        assert edit_ctx.form.cancel_url == "/app/task/{id}"

    def test_view_context_urls_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert view_ctx.detail.edit_url == "/app/task/{id}/edit"
        assert view_ctx.detail.back_url == "/app/task"

    def test_view_context_delete_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert not view_ctx.detail.delete_url.startswith("/app")

    def test_workspace_nav_items_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        # Check any non-root context has nav items with prefix
        list_ctx = contexts["/app/task"]
        assert list_ctx.nav_items
        assert list_ctx.nav_items[0].route == "/app/workspaces/main"

    def test_root_route_preserved(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        assert "/" in contexts

    def test_no_prefix_when_not_specified(self) -> None:
        """Backward compat: no prefix by default."""
        contexts = compile_appspec_to_templates(_make_appspec())
        assert "/task" in contexts
        assert "/task/create" in contexts
        assert "/task/{id}" in contexts
        assert "/task/{id}/edit" in contexts


# ===================================================================
# 2. compile_surface_to_context with app_prefix
# ===================================================================


class TestSurfaceContextPrefix:
    """Verify compile_surface_to_context respects app_prefix."""

    def test_list_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity(), app_prefix="/app")
        assert ctx.table is not None
        assert ctx.table.create_url == "/app/task/create"
        assert ctx.table.detail_url_template == "/app/task/{id}"

    def test_create_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_create_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task"

    def test_edit_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_edit_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task/{id}"

    def test_view_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_view_surface(), _task_entity(), app_prefix="/app")
        assert ctx.detail is not None
        assert ctx.detail.edit_url == "/app/task/{id}/edit"
        assert ctx.detail.back_url == "/app/task"

    def test_no_prefix_by_default(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity())
        assert ctx.table is not None
        assert ctx.table.create_url == "/task/create"
        assert ctx.table.detail_url_template == "/task/{id}"


# ===================================================================
# 3. HX-Redirect after create
# ===================================================================

pytest.importorskip("fastapi")

from dazzle_back.runtime.route_generator import (  # noqa: E402
    _extract_result_id,
    _with_htmx_triggers,
    create_create_handler,
)


class TestExtractResultId:
    """Test _extract_result_id helper."""

    def test_from_pydantic_model(self) -> None:
        model = MagicMock()
        model.id = uuid4()
        assert _extract_result_id(model) == str(model.id)

    def test_from_dict(self) -> None:
        uid = uuid4()
        assert _extract_result_id({"id": uid}) == str(uid)

    def test_returns_none_for_missing_id(self) -> None:
        assert _extract_result_id({"name": "foo"}) is None
        assert _extract_result_id(42) is None


class TestHxRedirectHeader:
    """Test that _with_htmx_triggers includes HX-Redirect when redirect_url is provided."""

    def _htmx_request(self) -> MagicMock:
        request = MagicMock()
        request.headers = {"HX-Request": "true"}
        return request

    def test_redirect_header_present(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123", "title": "Test"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        assert resp.headers.get("HX-Redirect") == "/app/task/abc-123"

    def test_no_redirect_header_when_none(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(request, result, "Task", "created")
        assert "HX-Redirect" not in resp.headers

    def test_non_htmx_request_returns_raw_result(self) -> None:
        request = MagicMock()
        request.headers = {}
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        # Non-HTMX should return the raw result, not a JSONResponse
        assert resp is result


class TestCreateHandlerRedirect:
    """Test that create handler generates HX-Redirect to detail page."""

    @pytest.mark.asyncio
    async def test_create_handler_returns_hx_redirect(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            entity_slug="task",
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert resp.headers.get("HX-Redirect") == f"/app/task/{uid}"

    @pytest.mark.asyncio
    async def test_create_handler_no_redirect_without_slug(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            # no entity_slug — backward compat
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert "HX-Redirect" not in resp.headers
