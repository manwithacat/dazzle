"""Tests for URL prefix consistency and post-create HX-Redirect.

Ensures that page URLs generated by the template compiler match the
router mount prefix, and that HTMX create responses redirect to the
detail page.
"""

from __future__ import annotations

from typing import Any
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

import pytest

from dazzle.core.ir import (
    AppSpec,
    DomainSpec,
    EntitySpec,
    FieldModifier,
    FieldSpec,
    FieldType,
    FieldTypeKind,
    SurfaceElement,
    SurfaceMode,
    SurfaceSection,
    SurfaceSpec,
    WorkspaceSpec,
)

pytest.importorskip("dazzle_ui.converters.template_compiler")

from dazzle_ui.converters.template_compiler import (  # noqa: E402
    compile_appspec_to_templates,
    compile_surface_to_context,
)

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _task_entity() -> EntitySpec:
    return EntitySpec(
        name="Task",
        title="Task",
        fields=[
            FieldSpec(
                name="id",
                type=FieldType(kind=FieldTypeKind.UUID),
                modifiers=[FieldModifier.PK],
            ),
            FieldSpec(
                name="title",
                type=FieldType(kind=FieldTypeKind.STR, max_length=200),
                modifiers=[FieldModifier.REQUIRED],
            ),
            FieldSpec(
                name="completed",
                type=FieldType(kind=FieldTypeKind.BOOL),
                default=False,
            ),
        ],
    )


def _list_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_list",
        title="Tasks",
        entity_ref="Task",
        mode=SurfaceMode.LIST,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _create_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_create",
        title="Create Task",
        entity_ref="Task",
        mode=SurfaceMode.CREATE,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _edit_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_edit",
        title="Edit Task",
        entity_ref="Task",
        mode=SurfaceMode.EDIT,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _view_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_view",
        title="Task Details",
        entity_ref="Task",
        mode=SurfaceMode.VIEW,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _make_appspec() -> AppSpec:
    entity = _task_entity()
    return AppSpec(
        name="test_app",
        title="Test App",
        domain=DomainSpec(entities=[entity]),
        surfaces=[
            _list_surface(),
            _create_surface(),
            _edit_surface(),
            _view_surface(),
        ],
        workspaces=[
            WorkspaceSpec(name="main", title="Main"),
        ],
    )


# ===================================================================
# 1. URL prefix consistency — compile_appspec_to_templates
# ===================================================================


class TestUrlPrefixConsistency:
    """Verify that app_prefix is applied to all page URLs but not API paths."""

    def test_route_keys_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        for route_path in contexts:
            if route_path != "/":
                assert route_path.startswith("/app/"), f"Route {route_path!r} missing /app prefix"

    def test_list_context_urls_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert list_ctx.table.create_url == "/app/task/create"
        assert list_ctx.table.detail_url_template == "/app/task/{id}"

    def test_list_context_api_endpoint_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert not list_ctx.table.api_endpoint.startswith("/app")

    def test_create_context_cancel_url_matches_list_route(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert create_ctx.form.cancel_url == "/app/task"
        # cancel_url must be a valid route
        assert "/app/task" in contexts

    def test_create_context_action_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert not create_ctx.form.action_url.startswith("/app")

    def test_edit_context_cancel_url_uses_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        edit_ctx = contexts["/app/task/{id}/edit"]
        assert edit_ctx.form is not None
        assert edit_ctx.form.cancel_url == "/app/task/{id}"

    def test_view_context_urls_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert view_ctx.detail.edit_url == "/app/task/{id}/edit"
        assert view_ctx.detail.back_url == "/app/task"

    def test_view_context_delete_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert not view_ctx.detail.delete_url.startswith("/app")

    def test_workspace_nav_items_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        # Check any non-root context has nav items with prefix
        list_ctx = contexts["/app/task"]
        assert list_ctx.nav_items
        assert list_ctx.nav_items[0].route == "/app/workspaces/main"

    def test_root_route_skipped_when_workspaces_exist(self) -> None:
        """When workspaces exist, "/" is not registered as a fallback surface."""
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        assert "/" not in contexts

    def test_root_route_preserved_without_workspaces(self) -> None:
        """Without workspaces, "/" fallback to first list surface is kept."""
        appspec = AppSpec(
            name="simple_app",
            title="Simple App",
            domain=DomainSpec(entities=[_task_entity()]),
            surfaces=[_list_surface(), _create_surface()],
            workspaces=[],
        )
        contexts = compile_appspec_to_templates(appspec, app_prefix="/app")
        assert "/" in contexts

    def test_no_prefix_when_not_specified(self) -> None:
        """Backward compat: no prefix by default."""
        contexts = compile_appspec_to_templates(_make_appspec())
        assert "/task" in contexts
        assert "/task/create" in contexts
        assert "/task/{id}" in contexts
        assert "/task/{id}/edit" in contexts


# ===================================================================
# 2. compile_surface_to_context with app_prefix
# ===================================================================


class TestSurfaceContextPrefix:
    """Verify compile_surface_to_context respects app_prefix."""

    def test_list_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity(), app_prefix="/app")
        assert ctx.table is not None
        assert ctx.table.create_url == "/app/task/create"
        assert ctx.table.detail_url_template == "/app/task/{id}"

    def test_create_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_create_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task"

    def test_edit_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_edit_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task/{id}"

    def test_view_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_view_surface(), _task_entity(), app_prefix="/app")
        assert ctx.detail is not None
        assert ctx.detail.edit_url == "/app/task/{id}/edit"
        assert ctx.detail.back_url == "/app/task"

    def test_no_prefix_by_default(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity())
        assert ctx.table is not None
        assert ctx.table.create_url == "/task/create"
        assert ctx.table.detail_url_template == "/task/{id}"


# ===================================================================
# 3. HX-Redirect after create
# ===================================================================

pytest.importorskip("fastapi")

from dazzle_back.runtime.route_generator import (  # noqa: E402
    _extract_result_id,
    _htmx_current_url,
    _htmx_parent_url,
    _with_htmx_triggers,
    create_create_handler,
)


class TestExtractResultId:
    """Test _extract_result_id helper."""

    def test_from_pydantic_model(self) -> None:
        model = MagicMock()
        model.id = uuid4()
        assert _extract_result_id(model) == str(model.id)

    def test_from_dict(self) -> None:
        uid = uuid4()
        assert _extract_result_id({"id": uid}) == str(uid)

    def test_returns_none_for_missing_id(self) -> None:
        assert _extract_result_id({"name": "foo"}) is None
        assert _extract_result_id(42) is None


class TestHxRedirectHeader:
    """Test that _with_htmx_triggers includes HX-Redirect when redirect_url is provided."""

    def _htmx_request(self) -> MagicMock:
        request = MagicMock()
        request.headers = {"HX-Request": "true"}
        return request

    def test_redirect_header_present(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123", "title": "Test"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        assert resp.headers.get("HX-Redirect") == "/app/task/abc-123"

    def test_no_redirect_header_when_none(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(request, result, "Task", "created")
        assert "HX-Redirect" not in resp.headers

    def test_non_htmx_request_returns_raw_result(self) -> None:
        request = MagicMock()
        request.headers = {}
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        # Non-HTMX should return the raw result, not a JSONResponse
        assert resp is result


class TestCreateHandlerRedirect:
    """Test that create handler generates HX-Redirect to detail page."""

    @pytest.mark.asyncio
    async def test_create_handler_returns_hx_redirect(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            entity_slug="task",
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert resp.headers.get("HX-Redirect") == f"/app/task/{uid}"

    @pytest.mark.asyncio
    async def test_create_handler_no_redirect_without_slug(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            # no entity_slug — backward compat
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert "HX-Redirect" not in resp.headers


class TestHtmxCurrentUrl:
    """Test _htmx_current_url helper."""

    def test_returns_url_for_htmx_request(self) -> None:
        request = MagicMock()
        request.headers = {
            "HX-Request": "true",
            "hx-current-url": "http://localhost:3000/tasks/abc",
        }
        assert _htmx_current_url(request) == "http://localhost:3000/tasks/abc"

    def test_returns_none_for_non_htmx(self) -> None:
        request = MagicMock()
        request.headers = {}
        assert _htmx_current_url(request) is None

    def test_returns_none_when_header_missing(self) -> None:
        request = MagicMock()
        request.headers = {"HX-Request": "true"}
        assert _htmx_current_url(request) is None


class TestHtmxParentUrl:
    """Test _htmx_parent_url helper for post-delete redirect."""

    def test_strips_trailing_id_segment(self) -> None:
        request = MagicMock()
        request.headers = {
            "HX-Request": "true",
            "hx-current-url": "http://localhost:3000/tasks/abc-123",
        }
        assert _htmx_parent_url(request) == "/tasks"

    def test_returns_root_for_single_segment(self) -> None:
        request = MagicMock()
        request.headers = {"HX-Request": "true", "hx-current-url": "http://localhost:3000/tasks"}
        assert _htmx_parent_url(request) == "/"

    def test_returns_none_for_non_htmx(self) -> None:
        request = MagicMock()
        request.headers = {}
        assert _htmx_parent_url(request) is None


# ===================================================================
# 5. Internal fetch cookie forwarding & backend URL resolution
# ===================================================================

from dazzle_ui.runtime.page_routes import (  # noqa: E402
    _resolve_backend_url,
    _sync_fetch,
)


class TestResolveBackendUrl:
    """Test _resolve_backend_url prefers PORT env var for localhost."""

    def test_uses_port_env_var(self, monkeypatch: pytest.MonkeyPatch) -> None:
        monkeypatch.setenv("PORT", "12345")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:12345"

    def test_falls_back_to_base_url(self, monkeypatch: pytest.MonkeyPatch) -> None:
        monkeypatch.delenv("PORT", raising=False)
        request = MagicMock()
        request.base_url = "http://localhost:3000/"
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://localhost:3000"

    def test_falls_back_to_default(self, monkeypatch: pytest.MonkeyPatch) -> None:
        monkeypatch.delenv("PORT", raising=False)
        request = MagicMock()
        request.base_url = ""
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:8000"


class TestSyncFetchCookies:
    """Test that _sync_fetch forwards cookies as Cookie header."""

    def test_cookie_header_set(self) -> None:
        """Verify Cookie header is added to the request object."""
        import urllib.request as urlreq

        calls: list[urlreq.Request] = []
        original_urlopen = urlreq.urlopen

        def mock_urlopen(req: urlreq.Request, **kwargs: Any) -> Any:
            calls.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"ok": true}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        urlreq.urlopen = mock_urlopen  # type: ignore[assignment]
        try:
            _sync_fetch("http://localhost/test", cookies={"session": "abc123"})
            assert len(calls) == 1
            cookie_header = calls[0].get_header("Cookie")
            assert cookie_header == "session=abc123"
        finally:
            urlreq.urlopen = original_urlopen  # type: ignore[assignment]

    def test_no_cookie_header_when_none(self) -> None:
        """Verify no Cookie header when cookies is None."""
        import urllib.request as urlreq

        calls: list[urlreq.Request] = []

        def mock_urlopen(req: urlreq.Request, **kwargs: Any) -> Any:
            calls.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"ok": true}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        original_urlopen = urlreq.urlopen
        urlreq.urlopen = mock_urlopen  # type: ignore[assignment]
        try:
            _sync_fetch("http://localhost/test")
            assert len(calls) == 1
            assert calls[0].get_header("Cookie") is None
        finally:
            urlreq.urlopen = original_urlopen  # type: ignore[assignment]
