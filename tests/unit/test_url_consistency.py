"""Tests for URL prefix consistency and post-create HX-Redirect.

Ensures that page URLs generated by the template compiler match the
router mount prefix, and that HTMX create responses redirect to the
detail page.
"""

from __future__ import annotations

from typing import Any
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

import pytest

from dazzle.core.ir import (
    AppSpec,
    DomainSpec,
    EntitySpec,
    FieldModifier,
    FieldSpec,
    FieldType,
    FieldTypeKind,
    SurfaceElement,
    SurfaceMode,
    SurfaceSection,
    SurfaceSpec,
    WorkspaceSpec,
)

pytest.importorskip("dazzle_ui.converters.template_compiler")

from dazzle_ui.converters.template_compiler import (  # noqa: E402
    compile_appspec_to_templates,
    compile_surface_to_context,
)

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _task_entity() -> EntitySpec:
    return EntitySpec(
        name="Task",
        title="Task",
        fields=[
            FieldSpec(
                name="id",
                type=FieldType(kind=FieldTypeKind.UUID),
                modifiers=[FieldModifier.PK],
            ),
            FieldSpec(
                name="title",
                type=FieldType(kind=FieldTypeKind.STR, max_length=200),
                modifiers=[FieldModifier.REQUIRED],
            ),
            FieldSpec(
                name="completed",
                type=FieldType(kind=FieldTypeKind.BOOL),
                default=False,
            ),
        ],
    )


def _list_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_list",
        title="Tasks",
        entity_ref="Task",
        mode=SurfaceMode.LIST,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _create_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_create",
        title="Create Task",
        entity_ref="Task",
        mode=SurfaceMode.CREATE,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                    SurfaceElement(field_name="completed", label="Done"),
                ],
            )
        ],
    )


def _edit_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_edit",
        title="Edit Task",
        entity_ref="Task",
        mode=SurfaceMode.EDIT,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _view_surface() -> SurfaceSpec:
    return SurfaceSpec(
        name="task_view",
        title="Task Details",
        entity_ref="Task",
        mode=SurfaceMode.VIEW,
        sections=[
            SurfaceSection(
                name="main",
                title="Main",
                elements=[
                    SurfaceElement(field_name="title", label="Title"),
                ],
            )
        ],
    )


def _make_appspec() -> AppSpec:
    entity = _task_entity()
    return AppSpec(
        name="test_app",
        title="Test App",
        domain=DomainSpec(entities=[entity]),
        surfaces=[
            _list_surface(),
            _create_surface(),
            _edit_surface(),
            _view_surface(),
        ],
        workspaces=[
            WorkspaceSpec(name="main", title="Main"),
        ],
    )


# ===================================================================
# 1. URL prefix consistency — compile_appspec_to_templates
# ===================================================================


class TestUrlPrefixConsistency:
    """Verify that app_prefix is applied to all page URLs but not API paths."""

    def test_route_keys_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        for route_path in contexts:
            if route_path != "/":
                assert route_path.startswith("/app/"), f"Route {route_path!r} missing /app prefix"

    def test_list_context_urls_use_app_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert list_ctx.table.create_url == "/app/task/create"
        assert list_ctx.table.detail_url_template == "/app/task/{id}"

    def test_list_context_api_endpoint_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        list_ctx = contexts["/app/task"]
        assert list_ctx.table is not None
        assert not list_ctx.table.api_endpoint.startswith("/app")

    def test_create_context_cancel_url_matches_list_route(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert create_ctx.form.cancel_url == "/app/task"
        # cancel_url must be a valid route
        assert "/app/task" in contexts

    def test_create_context_action_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        create_ctx = contexts["/app/task/create"]
        assert create_ctx.form is not None
        assert not create_ctx.form.action_url.startswith("/app")

    def test_edit_context_cancel_url_uses_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        edit_ctx = contexts["/app/task/{id}/edit"]
        assert edit_ctx.form is not None
        assert edit_ctx.form.cancel_url == "/app/task/{id}"

    def test_view_context_urls_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert view_ctx.detail.edit_url == "/app/task/{id}/edit"
        assert view_ctx.detail.back_url == "/app/task"

    def test_view_context_delete_url_not_prefixed(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        view_ctx = contexts["/app/task/{id}"]
        assert view_ctx.detail is not None
        assert not view_ctx.detail.delete_url.startswith("/app")

    def test_workspace_nav_items_use_prefix(self) -> None:
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        # Check any non-root context has nav items with prefix
        list_ctx = contexts["/app/task"]
        assert list_ctx.nav_items
        assert list_ctx.nav_items[0].route == "/app/workspaces/main"

    def test_root_route_skipped_when_workspaces_exist(self) -> None:
        """When workspaces exist, "/" is not registered as a fallback surface."""
        contexts = compile_appspec_to_templates(_make_appspec(), app_prefix="/app")
        assert "/" not in contexts

    def test_root_route_preserved_without_workspaces(self) -> None:
        """Without workspaces, "/" fallback to first list surface is kept."""
        appspec = AppSpec(
            name="simple_app",
            title="Simple App",
            domain=DomainSpec(entities=[_task_entity()]),
            surfaces=[_list_surface(), _create_surface()],
            workspaces=[],
        )
        contexts = compile_appspec_to_templates(appspec, app_prefix="/app")
        assert "/" in contexts

    def test_no_prefix_when_not_specified(self) -> None:
        """Backward compat: no prefix by default."""
        contexts = compile_appspec_to_templates(_make_appspec())
        assert "/task" in contexts
        assert "/task/create" in contexts
        assert "/task/{id}" in contexts
        assert "/task/{id}/edit" in contexts


# ===================================================================
# 2. compile_surface_to_context with app_prefix
# ===================================================================


class TestSurfaceContextPrefix:
    """Verify compile_surface_to_context respects app_prefix."""

    def test_list_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity(), app_prefix="/app")
        assert ctx.table is not None
        assert ctx.table.create_url == "/app/task/create"
        assert ctx.table.detail_url_template == "/app/task/{id}"

    def test_create_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_create_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task"

    def test_edit_surface_cancel_url_prefixed(self) -> None:
        ctx = compile_surface_to_context(_edit_surface(), _task_entity(), app_prefix="/app")
        assert ctx.form is not None
        assert ctx.form.cancel_url == "/app/task/{id}"

    def test_view_surface_urls_prefixed(self) -> None:
        ctx = compile_surface_to_context(_view_surface(), _task_entity(), app_prefix="/app")
        assert ctx.detail is not None
        assert ctx.detail.edit_url == "/app/task/{id}/edit"
        assert ctx.detail.back_url == "/app/task"

    def test_no_prefix_by_default(self) -> None:
        ctx = compile_surface_to_context(_list_surface(), _task_entity())
        assert ctx.table is not None
        assert ctx.table.create_url == "/task/create"
        assert ctx.table.detail_url_template == "/task/{id}"


# ===================================================================
# 3. HX-Redirect after create
# ===================================================================

pytest.importorskip("fastapi")

from dazzle_back.runtime.route_generator import (  # noqa: E402
    _extract_result_id,
    _htmx_current_url,
    _htmx_parent_url,
    _with_htmx_triggers,
    create_create_handler,
)


class TestExtractResultId:
    """Test _extract_result_id helper."""

    def test_from_pydantic_model(self) -> None:
        model = MagicMock()
        model.id = uuid4()
        assert _extract_result_id(model) == str(model.id)

    def test_from_dict(self) -> None:
        uid = uuid4()
        assert _extract_result_id({"id": uid}) == str(uid)

    def test_returns_none_for_missing_id(self) -> None:
        assert _extract_result_id({"name": "foo"}) is None
        assert _extract_result_id(42) is None


class TestHxRedirectHeader:
    """Test that _with_htmx_triggers includes HX-Redirect when redirect_url is provided."""

    def _htmx_request(self) -> MagicMock:
        request = MagicMock()
        request.headers = {"HX-Request": "true"}
        return request

    def test_redirect_header_present(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123", "title": "Test"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        assert resp.headers.get("HX-Redirect") == "/app/task/abc-123"

    def test_no_redirect_header_when_none(self) -> None:
        request = self._htmx_request()
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(request, result, "Task", "created")
        assert "HX-Redirect" not in resp.headers

    def test_non_htmx_request_returns_raw_result(self) -> None:
        request = MagicMock()
        request.headers = {}
        result = {"id": "abc-123"}
        resp = _with_htmx_triggers(
            request, result, "Task", "created", redirect_url="/app/task/abc-123"
        )
        # Non-HTMX should return the raw result, not a JSONResponse
        assert resp is result

    def test_dict_with_uuid_values_serializes(self) -> None:
        """Regression test for #297: UUID values in dict results must serialize."""
        request = self._htmx_request()
        uid = uuid4()
        result = {"id": uid, "parent_id": uuid4(), "title": "Test"}
        resp = _with_htmx_triggers(request, result, "Task", "updated")
        # Should not raise TypeError: Object of type UUID is not JSON serializable
        import json

        body = json.loads(resp.body)
        assert body["id"] == str(uid)
        assert body["title"] == "Test"

    def test_dict_with_nested_uuid_serializes(self) -> None:
        """UUID values nested in sub-dicts/lists also serialize."""
        request = self._htmx_request()
        uid = uuid4()
        result = {"id": str(uuid4()), "refs": [{"target_id": uid}]}
        resp = _with_htmx_triggers(request, result, "Task", "updated")
        import json

        body = json.loads(resp.body)
        assert body["refs"][0]["target_id"] == str(uid)


class TestCreateHandlerRedirect:
    """Test that create handler generates HX-Redirect to detail page."""

    @pytest.mark.asyncio
    async def test_create_handler_returns_hx_redirect(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            entity_slug="task",
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert resp.headers.get("HX-Redirect") == f"/app/task/{uid}"

    @pytest.mark.asyncio
    async def test_create_handler_no_redirect_without_slug(self) -> None:
        uid = str(uuid4())
        service = AsyncMock()
        service.execute = AsyncMock(return_value={"id": uid, "title": "Test"})

        from pydantic import BaseModel

        class TaskCreate(BaseModel):
            title: str

        handler = create_create_handler(
            service,
            TaskCreate,
            entity_name="Task",
            # no entity_slug — backward compat
        )

        request = MagicMock()
        request.headers = {"HX-Request": "true", "content-type": "application/json"}
        request.json = AsyncMock(return_value={"title": "Test"})

        resp = await handler(request)
        assert "HX-Redirect" not in resp.headers


class TestHtmxCurrentUrl:
    """Test _htmx_current_url helper."""

    def test_returns_url_for_htmx_request(self) -> None:
        request = MagicMock()
        request.headers = {
            "HX-Request": "true",
            "hx-current-url": "http://localhost:3000/tasks/abc",
        }
        assert _htmx_current_url(request) == "http://localhost:3000/tasks/abc"

    def test_returns_none_for_non_htmx(self) -> None:
        request = MagicMock()
        request.headers = {}
        assert _htmx_current_url(request) is None

    def test_returns_none_when_header_missing(self) -> None:
        request = MagicMock()
        request.headers = {"HX-Request": "true"}
        assert _htmx_current_url(request) is None


class TestHtmxParentUrl:
    """Test _htmx_parent_url helper for post-delete redirect."""

    def test_strips_trailing_id_segment(self) -> None:
        request = MagicMock()
        request.headers = {
            "HX-Request": "true",
            "hx-current-url": "http://localhost:3000/tasks/abc-123",
        }
        assert _htmx_parent_url(request) == "/tasks"

    def test_returns_root_for_single_segment(self) -> None:
        request = MagicMock()
        request.headers = {"HX-Request": "true", "hx-current-url": "http://localhost:3000/tasks"}
        assert _htmx_parent_url(request) == "/"

    def test_returns_none_for_non_htmx(self) -> None:
        request = MagicMock()
        request.headers = {}
        assert _htmx_parent_url(request) is None


# ===================================================================
# 5. Internal fetch cookie forwarding & backend URL resolution
# ===================================================================

from dazzle_ui.runtime.page_routes import (  # noqa: E402
    _resolve_backend_url,
    _sync_fetch,
)


class TestResolveBackendUrl:
    """Test _resolve_backend_url across deployment topologies.

    Resolution priority:
    1. DAZZLE_BACKEND_URL env var (explicit split-service override)
    2. PORT env var (single-dyno platforms like Heroku)
    3. request.base_url (same-origin setups)
    4. fallback parameter (local dev default)
    """

    def _clean_env(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Ensure neither env var is set for a clean baseline."""
        monkeypatch.delenv("DAZZLE_BACKEND_URL", raising=False)
        monkeypatch.delenv("PORT", raising=False)

    # --- Topology 1: Local dev (no env vars) ---

    def test_local_dev_uses_fallback(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Local dev: no env vars, base_url empty → hardcoded fallback."""
        self._clean_env(monkeypatch)
        request = MagicMock()
        request.base_url = ""
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:8000"

    def test_local_dev_uses_base_url(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Local dev: no env vars, base_url available → use it."""
        self._clean_env(monkeypatch)
        request = MagicMock()
        request.base_url = "http://localhost:3000/"
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://localhost:3000"

    # --- Topology 2: Single dyno (Heroku, Railway) ---

    def test_single_dyno_uses_port(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Single dyno: PORT set → localhost with dynamic port."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("PORT", "12345")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:12345"

    def test_single_dyno_port_beats_base_url(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Single dyno: PORT takes priority over request.base_url."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("PORT", "5000")
        request = MagicMock()
        request.base_url = "https://myapp.herokuapp.com/"
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:5000"

    # --- Topology 3: Split services (frontend ≠ backend) ---

    def test_split_service_explicit_url(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Split services: DAZZLE_BACKEND_URL set → use it directly."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("DAZZLE_BACKEND_URL", "https://api.example.com")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "https://api.example.com"

    def test_split_service_strips_trailing_slash(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Trailing slash on DAZZLE_BACKEND_URL is stripped."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("DAZZLE_BACKEND_URL", "https://api.example.com/")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "https://api.example.com"

    def test_split_service_beats_port(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """DAZZLE_BACKEND_URL takes priority over PORT."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("DAZZLE_BACKEND_URL", "http://backend:9000")
        monkeypatch.setenv("PORT", "3000")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://backend:9000"

    def test_split_service_internal_url(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Split services with internal network URL (AWS VPC, Docker network)."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("DAZZLE_BACKEND_URL", "http://backend.internal:8000")
        request = MagicMock()
        assert (
            _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://backend.internal:8000"
        )

    # --- Edge cases ---

    def test_empty_dazzle_backend_url_ignored(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Empty DAZZLE_BACKEND_URL falls through to next strategy."""
        self._clean_env(monkeypatch)
        monkeypatch.setenv("DAZZLE_BACKEND_URL", "")
        monkeypatch.setenv("PORT", "8080")
        request = MagicMock()
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:8080"

    def test_base_url_exception_handled(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """If request.base_url raises, fall through gracefully."""
        self._clean_env(monkeypatch)
        request = MagicMock()
        type(request).base_url = property(lambda self: (_ for _ in ()).throw(RuntimeError("boom")))
        assert _resolve_backend_url(request, "http://127.0.0.1:8000") == "http://127.0.0.1:8000"


class TestSyncFetchCookies:
    """Test that _sync_fetch forwards cookies as Cookie header."""

    def test_cookie_header_set(self) -> None:
        """Verify Cookie header is added to the request object."""
        import urllib.request as urlreq

        calls: list[urlreq.Request] = []
        original_urlopen = urlreq.urlopen

        def mock_urlopen(req: urlreq.Request, **kwargs: Any) -> Any:
            calls.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"ok": true}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        urlreq.urlopen = mock_urlopen  # type: ignore[assignment]
        try:
            _sync_fetch("http://localhost/test", cookies={"session": "abc123"})
            assert len(calls) == 1
            cookie_header = calls[0].get_header("Cookie")
            assert cookie_header == "session=abc123"
        finally:
            urlreq.urlopen = original_urlopen  # type: ignore[assignment]

    def test_no_cookie_header_when_none(self) -> None:
        """Verify no Cookie header when cookies is None."""
        import urllib.request as urlreq

        calls: list[urlreq.Request] = []

        def mock_urlopen(req: urlreq.Request, **kwargs: Any) -> Any:
            calls.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"ok": true}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        original_urlopen = urlreq.urlopen
        urlreq.urlopen = mock_urlopen  # type: ignore[assignment]
        try:
            _sync_fetch("http://localhost/test")
            assert len(calls) == 1
            assert calls[0].get_header("Cookie") is None
        finally:
            urlreq.urlopen = original_urlopen  # type: ignore[assignment]

    def test_multiple_cookies_joined(self) -> None:
        """Verify multiple cookies are semicolon-separated."""
        import urllib.request as urlreq

        calls: list[urlreq.Request] = []
        original_urlopen = urlreq.urlopen

        def mock_urlopen(req: urlreq.Request, **kwargs: Any) -> Any:
            calls.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"ok": true}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        urlreq.urlopen = mock_urlopen  # type: ignore[assignment]
        try:
            _sync_fetch(
                "http://localhost/test",
                cookies={"dazzle_session": "tok1", "csrf": "tok2"},
            )
            assert len(calls) == 1
            cookie_header = calls[0].get_header("Cookie")
            assert "dazzle_session=tok1" in cookie_header
            assert "csrf=tok2" in cookie_header
        finally:
            urlreq.urlopen = original_urlopen  # type: ignore[assignment]


# ===================================================================
# 6. Integration: _fetch_json across deployment topologies
# ===================================================================

from dazzle_ui.runtime.page_routes import _fetch_json  # noqa: E402


class TestFetchJsonTopologies:
    """Verify _fetch_json sends correct URL and cookies for each topology.

    Uses a mock urlopen to capture the actual request made, then asserts
    the URL and Cookie header match what the topology would produce.
    """

    @pytest.fixture(autouse=True)
    def _patch_urlopen(self) -> Any:
        """Patch urllib.request.urlopen to capture requests."""
        import urllib.request as urlreq

        self.captured: list[urlreq.Request] = []
        self._original = urlreq.urlopen

        def _mock(req: urlreq.Request, **kwargs: Any) -> Any:
            self.captured.append(req)
            resp = MagicMock()
            resp.read.return_value = b'{"id": "abc", "title": "Test"}'
            resp.__enter__ = lambda s: s
            resp.__exit__ = lambda s, *a: None
            return resp

        urlreq.urlopen = _mock  # type: ignore[assignment]
        yield
        urlreq.urlopen = self._original  # type: ignore[assignment]

    @pytest.mark.asyncio
    async def test_local_dev_no_cookies(self) -> None:
        """Local dev: localhost URL, no cookies needed (no auth)."""
        result = await _fetch_json("http://127.0.0.1:8000", "/tasks/{id}", "uuid-1")
        assert result["id"] == "abc"
        assert self.captured[0].full_url == "http://127.0.0.1:8000/tasks/uuid-1"
        assert self.captured[0].get_header("Cookie") is None

    @pytest.mark.asyncio
    async def test_heroku_single_dyno_with_cookies(self) -> None:
        """Single dyno: localhost with PORT, session cookie forwarded."""
        result = await _fetch_json(
            "http://127.0.0.1:5000",
            "/companies/{id}",
            "uuid-2",
            cookies={"dazzle_session": "heroku-tok"},
        )
        assert result["id"] == "abc"
        assert self.captured[0].full_url == "http://127.0.0.1:5000/companies/uuid-2"
        assert self.captured[0].get_header("Cookie") == "dazzle_session=heroku-tok"

    @pytest.mark.asyncio
    async def test_split_service_with_cookies(self) -> None:
        """Split services: external backend URL with cookies."""
        result = await _fetch_json(
            "https://api.example.com",
            "/contacts/{id}",
            "uuid-3",
            cookies={"dazzle_session": "split-tok", "csrf": "ct"},
        )
        assert result["id"] == "abc"
        assert self.captured[0].full_url == "https://api.example.com/contacts/uuid-3"
        cookie = self.captured[0].get_header("Cookie")
        assert "dazzle_session=split-tok" in cookie
        assert "csrf=ct" in cookie

    @pytest.mark.asyncio
    async def test_no_api_pattern_returns_error(self) -> None:
        """Missing API pattern returns error without making a request."""
        result = await _fetch_json("http://localhost:8000", None, "id-1")
        assert "error" in result
        assert len(self.captured) == 0

    @pytest.mark.asyncio
    async def test_pattern_without_id_placeholder_returns_error(self) -> None:
        """API pattern without {id} returns error without making a request."""
        result = await _fetch_json("http://localhost:8000", "/tasks", "id-1")
        assert "error" in result
        assert len(self.captured) == 0


class TestFetchJsonHttpServer:
    """Integration test with a real HTTP server to verify cookie forwarding end-to-end."""

    @pytest.mark.asyncio
    async def test_real_http_cookie_forwarding(self) -> None:
        """Start a real HTTP server, verify cookies arrive in the request."""
        import http.server
        import threading

        received_cookies: list[str | None] = []
        received_paths: list[str] = []

        class Handler(http.server.BaseHTTPRequestHandler):
            def do_GET(self) -> None:
                received_cookies.append(self.headers.get("Cookie"))
                received_paths.append(self.path)
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(b'{"id": "test-id", "name": "Test Entity"}')

            def log_message(self, format: str, *args: Any) -> None:
                pass  # Suppress server logs during tests

        server = http.server.HTTPServer(("127.0.0.1", 0), Handler)
        port = server.server_address[1]
        thread = threading.Thread(target=server.serve_forever)
        thread.daemon = True
        thread.start()

        try:
            result = await _fetch_json(
                f"http://127.0.0.1:{port}",
                "/entities/{id}",
                "abc-123",
                cookies={"dazzle_session": "real-session-token"},
            )

            assert result["id"] == "test-id"
            assert result["name"] == "Test Entity"
            assert len(received_paths) == 1
            assert received_paths[0] == "/entities/abc-123"
            assert received_cookies[0] == "dazzle_session=real-session-token"
        finally:
            server.shutdown()
