"""
Auto-generated conftest for Dazzle E2E tests.

Provides Playwright fixtures with console logging, route tracking,
and CRUD tracking infrastructure.

Generated by Dazzle playwright_codegen â€” safe to regenerate.
"""

from __future__ import annotations

import json
import os
from collections.abc import Generator
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

import pytest
from playwright.sync_api import Browser, ConsoleMessage, Page, sync_playwright

# Project root (for runtime file discovery)
PROJECT_ROOT = Path(__file__).parent.parent.parent

DEFAULT_UI_URL = "http://localhost:3000"
DEFAULT_API_URL = "http://localhost:8000"


def _load_runtime_ports() -> tuple[str, str]:
    """Load port config from .dazzle/runtime.json if available."""
    runtime_file = PROJECT_ROOT / ".dazzle" / "runtime.json"
    if runtime_file.exists():
        try:
            with open(runtime_file) as f:
                data = json.load(f)
            return (
                data.get("ui_url", DEFAULT_UI_URL),
                data.get("api_url", DEFAULT_API_URL),
            )
        except (json.JSONDecodeError, KeyError):
            pass
    return DEFAULT_UI_URL, DEFAULT_API_URL


# ---- Console diagnostics --------------------------------------------------


@dataclass
class ConsoleLogEntry:
    """A single browser console log entry."""

    type: str
    text: str
    url: str
    line_number: int


@dataclass
class PageDiagnostics:
    """Collected diagnostics from a page session."""

    console_logs: list[ConsoleLogEntry] = field(default_factory=list)
    page_errors: list[str] = field(default_factory=list)

    def add_console(self, msg: ConsoleMessage) -> None:
        loc = msg.location
        self.console_logs.append(
            ConsoleLogEntry(
                type=msg.type,
                text=msg.text,
                url=loc.get("url", ""),
                line_number=loc.get("lineNumber", 0),
            )
        )

    def add_error(self, error: Exception) -> None:
        self.page_errors.append(str(error))

    def has_errors(self) -> bool:
        return bool(self.page_errors) or any(log.type == "error" for log in self.console_logs)

    def get_errors(self) -> list[str]:
        errors = []
        for log in self.console_logs:
            if log.type == "error":
                errors.append(f"CONSOLE [{log.url}:{log.line_number}]: {log.text}")
        errors.extend(f"PAGE ERROR: {e}" for e in self.page_errors)
        return errors

    def print_summary(self, test_name: str = "") -> None:
        prefix = f"[{test_name}] " if test_name else ""
        if self.console_logs:
            print(f"\n{prefix}=== Console Logs ({len(self.console_logs)} entries) ===")
            for log in self.console_logs:
                loc = f"{log.url}:{log.line_number}" if log.url else "?"
                print(f"  {log.type.upper():8} [{loc}] {log.text[:200]}")
        if self.page_errors:
            print(f"\n{prefix}=== Page Errors ({len(self.page_errors)}) ===")
            for err in self.page_errors:
                print(f"  ERROR: {err[:200]}")


# ---- Route / CRUD tracking ------------------------------------------------


@dataclass
class RouteTracker:
    """Track navigated routes during a test."""

    routes: list[str] = field(default_factory=list)

    def __call__(self, route: str) -> None:
        self.routes.append(route)


@dataclass
class CrudTracker:
    """Track CRUD operations during a test."""

    ops: list[dict[str, Any]] = field(default_factory=list)

    def __call__(self, entity: str, action: str, **kwargs: Any) -> None:
        self.ops.append({"entity": entity, "action": action, **kwargs})


# ---- Fixtures --------------------------------------------------------------


@pytest.fixture(scope="session")
def base_url() -> str:
    """UI base URL (env var > runtime.json > default)."""
    if "DAZZLE_UI_URL" in os.environ:
        return os.environ["DAZZLE_UI_URL"]
    ui, _ = _load_runtime_ports()
    return ui


@pytest.fixture(scope="module")
def browser() -> Generator[Browser, None, None]:
    with sync_playwright() as p:
        b = p.chromium.launch(headless=True)
        yield b
        b.close()


@pytest.fixture
def page_diagnostics() -> PageDiagnostics:
    return PageDiagnostics()


@pytest.fixture
def page(
    browser: Browser, page_diagnostics: PageDiagnostics, request: Any
) -> Generator[Page, None, None]:
    context = browser.new_context(viewport={"width": 1280, "height": 720})
    pg = context.new_page()

    pg.on("console", lambda msg: page_diagnostics.add_console(msg))
    pg.on("pageerror", lambda err: page_diagnostics.add_error(err))

    yield pg

    test_name = request.node.name if request else ""
    if page_diagnostics.has_errors():
        page_diagnostics.print_summary(test_name)

    pg.close()
    context.close()


@pytest.fixture
def track_route() -> RouteTracker:
    return RouteTracker()


@pytest.fixture
def track_crud() -> CrudTracker:
    return CrudTracker()
